[{"path":[]},{"path":"https://danigiro.github.io/FoReco/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"interest fostering open welcoming environment, contributors maintainers pledge making participation project community harassment-free experience everyone, regardless age, body size, disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation.","code":""},{"path":"https://danigiro.github.io/FoReco/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes creating positive environment include: Using welcoming inclusive language respectful differing viewpoints experiences Gracefully accepting constructive criticism Focusing best community Showing empathy towards community members Examples unacceptable behavior participants include: use sexualized language imagery unwelcome sexual attention advances Trolling, insulting/derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical electronic address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://danigiro.github.io/FoReco/CODE_OF_CONDUCT.html","id":"our-responsibilities","dir":"","previous_headings":"","what":"Our Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Project maintainers responsible clarifying standards acceptable behavior expected take appropriate fair corrective action response instances unacceptable behavior. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, ban temporarily permanently contributor behaviors deem inappropriate, threatening, offensive, harmful.","code":""},{"path":"https://danigiro.github.io/FoReco/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within project spaces public spaces individual representing project community. Examples representing project community include using official project e-mail address, posting via official social media account, acting appointed representative online offline event. Representation project may defined clarified project maintainers.","code":""},{"path":"https://danigiro.github.io/FoReco/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported contacting project team daniele.girolimetto@phd.unipd.. complaints reviewed investigated result response deemed necessary appropriate circumstances. project team obligated maintain confidentiality regard reporter incident. details specific enforcement policies may posted separately. Project maintainers follow enforce Code Conduct good faith may face temporary permanent repercussions determined members project’s leadership.","code":""},{"path":"https://danigiro.github.io/FoReco/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 1.4, available https://www.contributor-covenant.org/version/1/4/code--conduct.html answers common questions code conduct, see https://www.contributor-covenant.org/faq","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) 2020 Daniele Girolimetto; Tommaso Di Fonzo  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. FoReco Copyright (C) 2020 Daniele Girolimetto; Tommaso Di Fonzo This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Cross-sectional forecast reconciliation","text":"vignette demonstrates use FoReco package cross-sectional forecast reconciliation. work examples using grouped general linearly constrained time series, showing obtain base forecasts, reconcile forecasts, address practical challenges non-negativity constraints immutable forecasts. also explore probabilistic forecast reconciliation. First, load necessary packages.","code":"library(FoReco)   # -> To perform reconciliation library(forecast)  # -> To obtain base forecasts"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"packages","dir":"Articles","previous_headings":"","what":"Packages","title":"Cross-sectional forecast reconciliation","text":"First, load necessary packages.","code":"library(FoReco)   # -> To perform reconciliation library(forecast)  # -> To obtain base forecasts"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"vndata-groupped-time-series","dir":"Articles","previous_headings":"","what":"vndata: Groupped time series","title":"Cross-sectional forecast reconciliation","text":"use vndata dataset (Wickramasuriya et al., 2018), contains grouped time series data, vnaggmat, corresponding aggregation matrix. See dataset vignette details. obtained base forecasts, fit ETS model log transformation series. handle zeros replacing half minimum non-zero value series (Wickramasuriya et al., 2020), fit ETS model generate forecasts. extract point forecasts residuals fitted models. apply various reconciliation methods base forecasts ensure add correctly across different levels aggregation. Bottom-reconciliation (Dunn et al., 1976) aggregates forecasts lowest level higher levels. top-reconciliation genuine hierarchical/grouped time series (Gross & Sohl, 1990), forecast Total (top-level series, expected positive) disaggregated according proportional scheme (weights) : top-level value remains unchanged; bottom time series reconciled forecasts non-negative. level conditional coherent reconciliation (LCC) generalization original proposal Hollyman et al. (2021) reconciled forecasts conditional (.e., constrained ) base forecasts specific upper level hierarchy (Di Fonzo & Girolimetto, 2024). Finally can obtained optimal (least squares sense) combination cross-sectional reconciled forecast (Girolimetto & Di Fonzo, 2023; Panagiotelis et al., 2021; Wickramasuriya et al., 2018). following table shows options optimal combination cross-sectional reconciliation function csrec(). Unfortunately, reconciled forecasts contain negative values, even though used non-negative base forecasts reconciliation. address issue, can use two approaches: State---art numerical optimization procedure, osqp (Stellato et al., 2020). Simple heuristic strategy: set-negative--zero, sntz (Di Fonzo & Girolimetto, 2023). Sometimes may wish incorporate priori knowledge reconciliation process (Zhang et al., 2023) order improve accuracy reconciled forecasts. example, suppose want fix forecasts states level series base forecasts values. Panagiotelis et al. (2023) shows sample reconciled distribution can obtained reconciling sample incoherent distribution. distinction incoherent sample reconciliation allows us separate two steps. can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . parametric method assumes normal distribution (Gaussian), generate incoherent sample set forecasts.","code":"data(vndata)      # dataset data(vnaggmat)    # Agg mat matrix model <- setNames(vector(mode='list', length=NCOL(vndata)), colnames(vndata)) fc_obj <- setNames(vector(mode='list', length=NCOL(vndata)), colnames(vndata))  # ETS model with log transformation ets_log <- function(x, ...){   x[x==0] <- min(x[x!=0])/2   ets(x, lambda = 0, ...) }  for(i in 1:NCOL(vndata)){   model[[i]] <- ets_log(vndata[, i])   fc_obj[[i]] <- forecast(model[[i]], h = 12) } # Point forecasts base <- do.call(cbind, lapply(fc_obj, function(x) x$mean)) str(base, give.attr = FALSE) #>  Time-Series [1:12, 1:525] from 2017 to 2018: 50651 21336 24567 29800 22846 ... # Residuals res <- do.call(cbind, lapply(fc_obj, residuals, type = \"response\")) str(res, give.attr = FALSE) #>  Time-Series [1:228, 1:525] from 1998 to 2017: 2143 -970 -115 133 951 ... fc_bts <- base[, colnames(vnaggmat)] rf_bu <- csbu(fc_bts, agg_mat = vnaggmat) str(rf_bu, give.attr = FALSE) #>  num [1:12, 1:525] 44094 18218 20585 25563 19385 ... bts <- vndata[, colnames(vnaggmat)] total <- vndata[, \"Total\"] fc_total <- base[, \"Total\"]  # Average historical proportions - Gross-Sohl method A p_gsa <- colMeans(apply(bts, 2, function(x) x/total)) rf_td_gsa <- cstd(fc_total, agg_mat = vnaggmat, weights = p_gsa) str(rf_td_gsa, give.attr = FALSE) #>  num [1:12, 1:525] 50651 21336 24567 29800 22846 ...  # Proportions of the historical averages - Gross-Sohl method F p_gsf <- colMeans(bts)/mean(total) rf_td_gsf <- cstd(fc_total, agg_mat = vnaggmat, weights = p_gsf) str(rf_td_gsf, give.attr = FALSE) #>  num [1:12, 1:525] 50651 21336 24567 29800 22846 ... rf_lcc <- cslcc(base = base, agg_mat = vnaggmat,                 res = res, comb = \"wls\") str(rf_lcc, give.attr = FALSE) #>  num [1:12, 1:525] 47896 20405 23276 28275 21938 ... rf_opt <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\") str(rf_opt, give.attr = FALSE) #>  num [1:12, 1:525] 49160 21622 24815 29433 23260 ... recoinfo(rf_opt) #> ✔ Optimal Cross-sectional Forecast Reconciliation #> ℹ FoReco function: `csrec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `FALSE` rf_osqp <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\", nn = \"osqp\") tmp <- recoinfo(rf_osqp) #> ✔ Optimal Cross-sectional Forecast Reconciliation #> ℹ FoReco function: `csrec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE` tmp$info # OSQP information matrix  #>     obj_val  run_time iter      pri_res status status_polish #> 1 -3197.129 0.1896877  450 4.896219e-11      1             1 rf_sntz <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\",                       nn = \"sntz\") recoinfo(rf_sntz) #> ✔ Optimal Cross-sectional Forecast Reconciliation #> ℹ FoReco function: `csrec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE` rf_imm <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\", immutable = c(2:8)) str(rf_imm, give.attr = FALSE) #>  num [1:12, 1:525] 50403 21300 24398 29664 22962 ... round(rf_imm[, 2:8] - base[, 2:8], 6) #>          A B C D E F G #> Jan 2017 0 0 0 0 0 0 0 #> Feb 2017 0 0 0 0 0 0 0 #> Mar 2017 0 0 0 0 0 0 0 #> Apr 2017 0 0 0 0 0 0 0 #> May 2017 0 0 0 0 0 0 0 #> Jun 2017 0 0 0 0 0 0 0 #> Jul 2017 0 0 0 0 0 0 0 #> Aug 2017 0 0 0 0 0 0 0 #> Sep 2017 0 0 0 0 0 0 0 #> Oct 2017 0 0 0 0 0 0 0 #> Nov 2017 0 0 0 0 0 0 0 #> Dec 2017 0 0 0 0 0 0 0 # Base forecasts' sample: # we simulate from the base models by sampling errors  # while keeping the cross-sectional dimension fixed. B <- 100 base_csjb <- csboot(model, B, 12)$sample reco_csjb <- cssample(base_csjb, agg_mat = vnaggmat, res = res, nn = \"sntz\",                    comb = \"shr\") class(reco_csjb) # distribution object #> [1] \"distribution\" \"vctrs_vctr\"   \"list\"  # Extracts mean: str(mean(reco_csjb), give.attr = FALSE) #>  num [1:12, 1:525] 49905 21594 25310 29837 23377 ... # Gaussian reconciled distribution with fixed base covariance matrix for different forecast horizon reco_csg_1 <- csgauss(base = base, agg_mat = vnaggmat, comb = \"shr\", res = res)  # Gaussian reconciled distribution with different base covariance matrix for each forecast horizon ## Multi-step residuals hres <- lapply(1:12, function(h)    sapply(model, residuals, type='response', h = h)) ## List of H=12 covariance matrix (one for each forecast horizon) cov_shr <- lapply(hres, function(r) cscov(comb = \"shr\", res = r))  reco_csg_h <- sapply(1:NROW(base), function(h){   csgauss(base = base[h, ], agg_mat = vnaggmat, comb = \"shr\", res = res, comb_base = cov_shr[[h]]) }) class(reco_csg_h) <- class(reco_csg_1) names(reco_csg_h) <- paste0(\"h-\", 1:length(reco_csg_h))  # Reconciled sample distribution starting from gaussian base forecasts base_css <- lapply(1:NROW(base), function(h) MASS::mvrnorm(n = B, mu = base[h, ], Sigma = cov_shr[[h]])) base_css <- aperm(simplify2array(base_css), c(3,2,1)) dimnames(base_css) <- dimnames(base_csjb)  reco_css <- cssample(base_css, agg_mat = vnaggmat, res = res, nn = \"sntz\",                    comb = \"shr\") class(reco_css) # distribution object #> [1] \"distribution\" \"vctrs_vctr\"   \"list\""},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"base-forecast","dir":"Articles","previous_headings":"","what":"Base forecast","title":"Cross-sectional forecast reconciliation","text":"obtained base forecasts, fit ETS model log transformation series. handle zeros replacing half minimum non-zero value series (Wickramasuriya et al., 2020), fit ETS model generate forecasts. extract point forecasts residuals fitted models.","code":"model <- setNames(vector(mode='list', length=NCOL(vndata)), colnames(vndata)) fc_obj <- setNames(vector(mode='list', length=NCOL(vndata)), colnames(vndata))  # ETS model with log transformation ets_log <- function(x, ...){   x[x==0] <- min(x[x!=0])/2   ets(x, lambda = 0, ...) }  for(i in 1:NCOL(vndata)){   model[[i]] <- ets_log(vndata[, i])   fc_obj[[i]] <- forecast(model[[i]], h = 12) } # Point forecasts base <- do.call(cbind, lapply(fc_obj, function(x) x$mean)) str(base, give.attr = FALSE) #>  Time-Series [1:12, 1:525] from 2017 to 2018: 50651 21336 24567 29800 22846 ... # Residuals res <- do.call(cbind, lapply(fc_obj, residuals, type = \"response\")) str(res, give.attr = FALSE) #>  Time-Series [1:228, 1:525] from 1998 to 2017: 2143 -970 -115 133 951 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"point-forecast-reconciliation","dir":"Articles","previous_headings":"","what":"Point forecast reconciliation","title":"Cross-sectional forecast reconciliation","text":"apply various reconciliation methods base forecasts ensure add correctly across different levels aggregation. Bottom-reconciliation (Dunn et al., 1976) aggregates forecasts lowest level higher levels. top-reconciliation genuine hierarchical/grouped time series (Gross & Sohl, 1990), forecast Total (top-level series, expected positive) disaggregated according proportional scheme (weights) : top-level value remains unchanged; bottom time series reconciled forecasts non-negative. level conditional coherent reconciliation (LCC) generalization original proposal Hollyman et al. (2021) reconciled forecasts conditional (.e., constrained ) base forecasts specific upper level hierarchy (Di Fonzo & Girolimetto, 2024). Finally can obtained optimal (least squares sense) combination cross-sectional reconciled forecast (Girolimetto & Di Fonzo, 2023; Panagiotelis et al., 2021; Wickramasuriya et al., 2018). following table shows options optimal combination cross-sectional reconciliation function csrec().","code":"fc_bts <- base[, colnames(vnaggmat)] rf_bu <- csbu(fc_bts, agg_mat = vnaggmat) str(rf_bu, give.attr = FALSE) #>  num [1:12, 1:525] 44094 18218 20585 25563 19385 ... bts <- vndata[, colnames(vnaggmat)] total <- vndata[, \"Total\"] fc_total <- base[, \"Total\"]  # Average historical proportions - Gross-Sohl method A p_gsa <- colMeans(apply(bts, 2, function(x) x/total)) rf_td_gsa <- cstd(fc_total, agg_mat = vnaggmat, weights = p_gsa) str(rf_td_gsa, give.attr = FALSE) #>  num [1:12, 1:525] 50651 21336 24567 29800 22846 ...  # Proportions of the historical averages - Gross-Sohl method F p_gsf <- colMeans(bts)/mean(total) rf_td_gsf <- cstd(fc_total, agg_mat = vnaggmat, weights = p_gsf) str(rf_td_gsf, give.attr = FALSE) #>  num [1:12, 1:525] 50651 21336 24567 29800 22846 ... rf_lcc <- cslcc(base = base, agg_mat = vnaggmat,                 res = res, comb = \"wls\") str(rf_lcc, give.attr = FALSE) #>  num [1:12, 1:525] 47896 20405 23276 28275 21938 ... rf_opt <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\") str(rf_opt, give.attr = FALSE) #>  num [1:12, 1:525] 49160 21622 24815 29433 23260 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"practical-challenges","dir":"Articles","previous_headings":"","what":"Practical challenges","title":"Cross-sectional forecast reconciliation","text":"Unfortunately, reconciled forecasts contain negative values, even though used non-negative base forecasts reconciliation. address issue, can use two approaches: State---art numerical optimization procedure, osqp (Stellato et al., 2020). Simple heuristic strategy: set-negative--zero, sntz (Di Fonzo & Girolimetto, 2023). Sometimes may wish incorporate priori knowledge reconciliation process (Zhang et al., 2023) order improve accuracy reconciled forecasts. example, suppose want fix forecasts states level series base forecasts values.","code":"recoinfo(rf_opt) #> ✔ Optimal Cross-sectional Forecast Reconciliation #> ℹ FoReco function: `csrec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `FALSE` rf_osqp <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\", nn = \"osqp\") tmp <- recoinfo(rf_osqp) #> ✔ Optimal Cross-sectional Forecast Reconciliation #> ℹ FoReco function: `csrec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE` tmp$info # OSQP information matrix  #>     obj_val  run_time iter      pri_res status status_polish #> 1 -3197.129 0.1896877  450 4.896219e-11      1             1 rf_sntz <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\",                       nn = \"sntz\") recoinfo(rf_sntz) #> ✔ Optimal Cross-sectional Forecast Reconciliation #> ℹ FoReco function: `csrec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE` rf_imm <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\", immutable = c(2:8)) str(rf_imm, give.attr = FALSE) #>  num [1:12, 1:525] 50403 21300 24398 29664 22962 ... round(rf_imm[, 2:8] - base[, 2:8], 6) #>          A B C D E F G #> Jan 2017 0 0 0 0 0 0 0 #> Feb 2017 0 0 0 0 0 0 0 #> Mar 2017 0 0 0 0 0 0 0 #> Apr 2017 0 0 0 0 0 0 0 #> May 2017 0 0 0 0 0 0 0 #> Jun 2017 0 0 0 0 0 0 0 #> Jul 2017 0 0 0 0 0 0 0 #> Aug 2017 0 0 0 0 0 0 0 #> Sep 2017 0 0 0 0 0 0 0 #> Oct 2017 0 0 0 0 0 0 0 #> Nov 2017 0 0 0 0 0 0 0 #> Dec 2017 0 0 0 0 0 0 0"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"non-negativity-issues","dir":"Articles","previous_headings":"vndata: Groupped time series","what":"Non negativity issues","title":"Cross-sectional forecast reconciliation","text":"Unfortunately, reconciled forecasts contain negative values, even though used non-negative base forecasts reconciliation. address issue, can use two approaches: State---art numerical optimization procedure, osqp (Stellato et al., 2020). Simple heuristic strategy: set-negative--zero, sntz (Di Fonzo & Girolimetto, 2023).","code":"recoinfo(rf_opt) #> ✔ Optimal Cross-sectional Forecast Reconciliation #> ℹ FoReco function: `csrec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `FALSE` rf_osqp <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\", nn = \"osqp\") tmp <- recoinfo(rf_osqp) #> ✔ Optimal Cross-sectional Forecast Reconciliation #> ℹ FoReco function: `csrec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE` tmp$info # OSQP information matrix  #>     obj_val  run_time iter      pri_res status status_polish #> 1 -3197.129 0.1896877  450 4.896219e-11      1             1 rf_sntz <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\",                       nn = \"sntz\") recoinfo(rf_sntz) #> ✔ Optimal Cross-sectional Forecast Reconciliation #> ℹ FoReco function: `csrec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE`"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"a-priori-constrained-immutable-forecasts","dir":"Articles","previous_headings":"vndata: Groupped time series","what":"A priori constrained (immutable) forecasts","title":"Cross-sectional forecast reconciliation","text":"Sometimes may wish incorporate priori knowledge reconciliation process (Zhang et al., 2023) order improve accuracy reconciled forecasts. example, suppose want fix forecasts states level series base forecasts values.","code":"rf_imm <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\", immutable = c(2:8)) str(rf_imm, give.attr = FALSE) #>  num [1:12, 1:525] 50403 21300 24398 29664 22962 ... round(rf_imm[, 2:8] - base[, 2:8], 6) #>          A B C D E F G #> Jan 2017 0 0 0 0 0 0 0 #> Feb 2017 0 0 0 0 0 0 0 #> Mar 2017 0 0 0 0 0 0 0 #> Apr 2017 0 0 0 0 0 0 0 #> May 2017 0 0 0 0 0 0 0 #> Jun 2017 0 0 0 0 0 0 0 #> Jul 2017 0 0 0 0 0 0 0 #> Aug 2017 0 0 0 0 0 0 0 #> Sep 2017 0 0 0 0 0 0 0 #> Oct 2017 0 0 0 0 0 0 0 #> Nov 2017 0 0 0 0 0 0 0 #> Dec 2017 0 0 0 0 0 0 0"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"probabilistic-forecast-reconciliation","dir":"Articles","previous_headings":"","what":"Probabilistic forecast reconciliation","title":"Cross-sectional forecast reconciliation","text":"Panagiotelis et al. (2023) shows sample reconciled distribution can obtained reconciling sample incoherent distribution. distinction incoherent sample reconciliation allows us separate two steps. can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . parametric method assumes normal distribution (Gaussian), generate incoherent sample set forecasts.","code":"# Base forecasts' sample: # we simulate from the base models by sampling errors  # while keeping the cross-sectional dimension fixed. B <- 100 base_csjb <- csboot(model, B, 12)$sample reco_csjb <- cssample(base_csjb, agg_mat = vnaggmat, res = res, nn = \"sntz\",                    comb = \"shr\") class(reco_csjb) # distribution object #> [1] \"distribution\" \"vctrs_vctr\"   \"list\"  # Extracts mean: str(mean(reco_csjb), give.attr = FALSE) #>  num [1:12, 1:525] 49905 21594 25310 29837 23377 ... # Gaussian reconciled distribution with fixed base covariance matrix for different forecast horizon reco_csg_1 <- csgauss(base = base, agg_mat = vnaggmat, comb = \"shr\", res = res)  # Gaussian reconciled distribution with different base covariance matrix for each forecast horizon ## Multi-step residuals hres <- lapply(1:12, function(h)    sapply(model, residuals, type='response', h = h)) ## List of H=12 covariance matrix (one for each forecast horizon) cov_shr <- lapply(hres, function(r) cscov(comb = \"shr\", res = r))  reco_csg_h <- sapply(1:NROW(base), function(h){   csgauss(base = base[h, ], agg_mat = vnaggmat, comb = \"shr\", res = res, comb_base = cov_shr[[h]]) }) class(reco_csg_h) <- class(reco_csg_1) names(reco_csg_h) <- paste0(\"h-\", 1:length(reco_csg_h))  # Reconciled sample distribution starting from gaussian base forecasts base_css <- lapply(1:NROW(base), function(h) MASS::mvrnorm(n = B, mu = base[h, ], Sigma = cov_shr[[h]])) base_css <- aperm(simplify2array(base_css), c(3,2,1)) dimnames(base_css) <- dimnames(base_csjb)  reco_css <- cssample(base_css, agg_mat = vnaggmat, res = res, nn = \"sntz\",                    comb = \"shr\") class(reco_css) # distribution object #> [1] \"distribution\" \"vctrs_vctr\"   \"list\""},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"itagdp-general-linearly-constrained-multiple-time-series","dir":"Articles","previous_headings":"","what":"itagdp: general linearly constrained multiple time series","title":"Cross-sectional forecast reconciliation","text":"section, work itagdp dataset corresponding zero-constrained matrix gdpconsmat. dataset illustrates reconciliation complex linear constraints unique aggregation available. See dataset vignette details. fit ARIMA models series generate base forecasts. apply optimal reconciliation method base forecasts, considering linear constraints defined gdpconsmat. case, want fix forecasts top level series (\\(GDP\\)) base forecasts values. can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . Alternatively, can use parametric method.","code":"data(itagdp)      # dataset data(gdpconsmat)  # Zero-constrained matrix model <- setNames(vector(mode='list', length=NCOL(itagdp)), colnames(itagdp)) fc_obj <- setNames(vector(mode='list', length=NCOL(itagdp)), colnames(itagdp)) for(i in 1:NCOL(itagdp)){   model[[i]] <- auto.arima(itagdp[, i])   fc_obj[[i]] <- forecast(model[[i]], h = 4) } # Point forecasts base <- do.call(cbind, lapply(fc_obj, function(x) x$mean)) str(base, give.attr = FALSE) #>  Time-Series [1:4, 1:21] from 2020 to 2021: 435117 454372 451935 483302 169348 ... # Residuals res <- do.call(cbind, lapply(fc_obj, function(x) x$residuals)) str(res, give.attr = FALSE) #>  Time-Series [1:80, 1:21] from 2000 to 2020: 167.9 89.7 51.4 -43.6 -630.9 ... rf_opt <- csrec(base = base, cons_mat = gdpconsmat, res = res, comb = \"wls\") str(rf_opt, give.attr = FALSE) #>  num [1:4, 1:21] 434329 453375 451278 482269 169366 ... rf_imm <- csrec(base = base, cons_mat = gdpconsmat, res = res, comb = \"wls\", immutable = c(1)) str(rf_imm, give.attr = FALSE) #>  num [1:4, 1:21] 435117 454372 451935 483302 169424 ... rf_imm[,1]-base[,1] #>      Qtr1 Qtr2 Qtr3 Qtr4 #> 2020    0    0    0    0 # Base forecasts' sample: # we simulate from the base models by sampling errors  # while keeping the cross-sectional dimension fixed. B <- 100 base_csjb <- csboot(model, B, 4)$sample reco_csjb <- cssample(base_csjb, cons_mat = gdpconsmat, res = res, comb = \"shr\") reco_csjb # distribution object #> <distribution[4]> #>         h-1         h-2         h-3         h-4  #> sample[100] sample[100] sample[100] sample[100]  # Extracts mean: str(mean(reco_csjb), give.attr = FALSE) #>  num [1:4, 1:21] 434177 452396 450616 481444 169100 ... # Gaussian reconciled distribution with fixed base covariance matrix for different forecast horizon reco_csg_1 <- csgauss(base = base, cons_mat = gdpconsmat, comb = \"shr\", res = res)  # Gaussian reconciled distribution with different base covariance matrix for each forecast horizon ## Multi-step residuals hres <- lapply(1:4, function(h)    sapply(model, residuals, type='response', h = h)) ## List of H=12 covariance matrix (one for each forecast horizon) cov_shr <- lapply(hres, function(r) cscov(comb = \"shr\", res = r))   reco_csg_h <- sapply(1:NROW(base), function(h){   csgauss(base = base[h, ], cons_mat = gdpconsmat, comb = \"shr\", res = res, comb_base = cov_shr[[h]]) }) class(reco_csg_h) <- class(reco_csg_1) names(reco_csg_h) <- paste0(\"h-\", 1:length(reco_csg_h))  # Reconciled sample distribution starting from gaussian base forecasts base_css <- lapply(1:NROW(base), function(h) MASS::mvrnorm(n = B, mu = base[h, ], Sigma = cov_shr[[h]])) base_css <- aperm(simplify2array(base_css), c(3,2,1)) dimnames(base_css) <- dimnames(base_csjb)  reco_css <- cssample(base_css, cons_mat = gdpconsmat, res = res, comb = \"shr\") class(reco_css) # distribution object #> [1] \"distribution\" \"vctrs_vctr\"   \"list\""},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"base-forecasts","dir":"Articles","previous_headings":"","what":"Base forecasts","title":"Cross-sectional forecast reconciliation","text":"fit ARIMA models series generate base forecasts.","code":"model <- setNames(vector(mode='list', length=NCOL(itagdp)), colnames(itagdp)) fc_obj <- setNames(vector(mode='list', length=NCOL(itagdp)), colnames(itagdp)) for(i in 1:NCOL(itagdp)){   model[[i]] <- auto.arima(itagdp[, i])   fc_obj[[i]] <- forecast(model[[i]], h = 4) } # Point forecasts base <- do.call(cbind, lapply(fc_obj, function(x) x$mean)) str(base, give.attr = FALSE) #>  Time-Series [1:4, 1:21] from 2020 to 2021: 435117 454372 451935 483302 169348 ... # Residuals res <- do.call(cbind, lapply(fc_obj, function(x) x$residuals)) str(res, give.attr = FALSE) #>  Time-Series [1:80, 1:21] from 2000 to 2020: 167.9 89.7 51.4 -43.6 -630.9 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"point-forecast-reconciliation-1","dir":"Articles","previous_headings":"","what":"Point forecast reconciliation","title":"Cross-sectional forecast reconciliation","text":"apply optimal reconciliation method base forecasts, considering linear constraints defined gdpconsmat. case, want fix forecasts top level series (\\(GDP\\)) base forecasts values.","code":"rf_opt <- csrec(base = base, cons_mat = gdpconsmat, res = res, comb = \"wls\") str(rf_opt, give.attr = FALSE) #>  num [1:4, 1:21] 434329 453375 451278 482269 169366 ... rf_imm <- csrec(base = base, cons_mat = gdpconsmat, res = res, comb = \"wls\", immutable = c(1)) str(rf_imm, give.attr = FALSE) #>  num [1:4, 1:21] 435117 454372 451935 483302 169424 ... rf_imm[,1]-base[,1] #>      Qtr1 Qtr2 Qtr3 Qtr4 #> 2020    0    0    0    0"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"practical-challenge-immutable-forecast","dir":"Articles","previous_headings":"itagdp: general linearly constrained multiple time series","what":"Practical challenge: immutable forecast","title":"Cross-sectional forecast reconciliation","text":"case, want fix forecasts top level series (\\(GDP\\)) base forecasts values.","code":"rf_imm <- csrec(base = base, cons_mat = gdpconsmat, res = res, comb = \"wls\", immutable = c(1)) str(rf_imm, give.attr = FALSE) #>  num [1:4, 1:21] 435117 454372 451935 483302 169424 ... rf_imm[,1]-base[,1] #>      Qtr1 Qtr2 Qtr3 Qtr4 #> 2020    0    0    0    0"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"probabilistic-forecast-reconciliation-1","dir":"Articles","previous_headings":"","what":"Probabilistic forecast reconciliation","title":"Cross-sectional forecast reconciliation","text":"can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . Alternatively, can use parametric method.","code":"# Base forecasts' sample: # we simulate from the base models by sampling errors  # while keeping the cross-sectional dimension fixed. B <- 100 base_csjb <- csboot(model, B, 4)$sample reco_csjb <- cssample(base_csjb, cons_mat = gdpconsmat, res = res, comb = \"shr\") reco_csjb # distribution object #> <distribution[4]> #>         h-1         h-2         h-3         h-4  #> sample[100] sample[100] sample[100] sample[100]  # Extracts mean: str(mean(reco_csjb), give.attr = FALSE) #>  num [1:4, 1:21] 434177 452396 450616 481444 169100 ... # Gaussian reconciled distribution with fixed base covariance matrix for different forecast horizon reco_csg_1 <- csgauss(base = base, cons_mat = gdpconsmat, comb = \"shr\", res = res)  # Gaussian reconciled distribution with different base covariance matrix for each forecast horizon ## Multi-step residuals hres <- lapply(1:4, function(h)    sapply(model, residuals, type='response', h = h)) ## List of H=12 covariance matrix (one for each forecast horizon) cov_shr <- lapply(hres, function(r) cscov(comb = \"shr\", res = r))   reco_csg_h <- sapply(1:NROW(base), function(h){   csgauss(base = base[h, ], cons_mat = gdpconsmat, comb = \"shr\", res = res, comb_base = cov_shr[[h]]) }) class(reco_csg_h) <- class(reco_csg_1) names(reco_csg_h) <- paste0(\"h-\", 1:length(reco_csg_h))  # Reconciled sample distribution starting from gaussian base forecasts base_css <- lapply(1:NROW(base), function(h) MASS::mvrnorm(n = B, mu = base[h, ], Sigma = cov_shr[[h]])) base_css <- aperm(simplify2array(base_css), c(3,2,1)) dimnames(base_css) <- dimnames(base_csjb)  reco_css <- cssample(base_css, cons_mat = gdpconsmat, res = res, comb = \"shr\") class(reco_css) # distribution object #> [1] \"distribution\" \"vctrs_vctr\"   \"list\""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Cross-temporal forecast reconciliation","text":"vignette demonstrates process cross-temporal forecast reconciliation using FoReco package. vignette covers following steps: Preparing loading necessary packages data. Generating base forecasts grouped time series. Reconciling point forecasts. Addressing practical challenges non-negativity issues. Exploring probabilistic forecast reconciliation. First, load necessary packages.","code":"library(FoReco)   # -> To perform reconciliation library(forecast)  # -> To obtain base forecasts library(GMCM)      # -> Sample from a multivariate normal distibution"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"packages","dir":"Articles","previous_headings":"","what":"Packages","title":"Cross-temporal forecast reconciliation","text":"First, load necessary packages.","code":"library(FoReco)   # -> To perform reconciliation library(forecast)  # -> To obtain base forecasts library(GMCM)      # -> Sample from a multivariate normal distibution"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"vndata-groupped-monthly-time-series","dir":"Articles","previous_headings":"","what":"vndata: Groupped monthly time series","title":"Cross-temporal forecast reconciliation","text":"use vndata dataset (Wickramasuriya et al., 2018), contains grouped monthly time series data, vnaggmat, corresponding aggregation matrix. See dataset vignette details. obtained base forecasts, fit ETS model log transformation series. handle zeros replacing half minimum non-zero value series (Wickramasuriya et al., 2020), fit ETS model generate forecasts. obtain twelve-, six-, four-, three-, two-, one-step-ahead base forecasts monthly data aggregation 2, 3, 4, 6, 12 months. extract point forecasts residuals fitted models. Within FoReco, range reconciliation strategies available, including bottom-, top-, level conditional coherent forecast reconciliation, cross-temporal heuristics. Bottom-reconciliation (Dunn et al., 1976) aggregates high-frequency forecasts lowest cross-sectional level higher cross-temporal levels (Girolimetto et al., 2024). obtain list forecasts different orders aggregation, can use FoReco2matrix function. top-reconciliation hierarchical time series, forecast top-level series (Total) distributed proportionally ensure top-level value stays bottom-level forecasts non-negative (Gross & Sohl, 1990). perform cross-temporal reconciliation FoReco using complete set base forecasts (cross-sectional temporal level), necessary arrange base forecasts (residuals) matrix form. rows matrix represent cross-sectional variables, columns temporal dimension. level conditional coherent reconciliation (LCC) generalization original proposal Hollyman et al. (2021) Di Fonzo & Girolimetto (2024) include cross-temporal framework iterative procedure described Di Fonzo & Girolimetto (2023a) produces cross-temporally reconciled forecasts alternating forecast reconciliation along one single dimension (either cross-sectional temporal) iteration step. cross-temporal method Kourentzes & Athanasopoulos (2019), involves three steps: first, reconciling forecasts time series different temporal aggregation levels using temporal hierarchies; second, performing cross-sectional reconciliation temporal aggregation order; third, averaging projection matrices second step using cross-sectionally reconcile forecasts first step. contrast, can reverses steps starting cross-sectional reconciliation followed temporal reconciliation (Di Fonzo & Girolimetto, 2023a). Finally can obtained optimal (least squares sense) combination cross-temporal reconciled forecast (Di Fonzo & Girolimetto, 2023a; Girolimetto et al., 2024). following table shows options optimal combination cross-temporal reconciliation function ctrec(). always true reconciled forecasts remain non-negative even base forecasts non-negative. example, consider case identity covariance matrix (\"ols\"). address issue, can use two approaches: State---art numerical optimization procedure, osqp (Stellato et al., 2020). Simple heuristic strategy: set-negative--zero, sntz (Di Fonzo & Girolimetto, 2023b). Sometimes may wish incorporate priori knowledge reconciliation process (Zhang et al., 2023) order improve accuracy reconciled forecasts. example, suppose want fix forecasts states level annual series base forecasts values. approaches far involved considering factors \\(m\\) potential aggregation orders. Nevertheless, worth noting also focus given subset factors. example, interested monthly, quarterly annual forecasts. Girolimetto et al. (2024) extends cross-temporal framework probabilistic results presented Panagiotelis et al. (2023) cross-sectional reconciliation. reconciliation probabilistic forecasts two-step process: first, sample incoherent distribution, reconcile sample. can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . parametric method assumes normal distribution (Gaussian), generate incoherent sample set forecasts. Since simulate multivariate normal distribution size 14700, use diagonal covariance matrix vignette. However, ’s important note choice result significantly narrow variance reconciled forecasts.","code":"data(vndata)      # dataset data(vnaggmat)    # Agg mat matrix te_set <- tetools(12)$set m <- max(te_set) data_k <- aggts(vndata, te_set) model <- setNames(rep(list(setNames(vector(mode='list', length=NCOL(vndata)), colnames(vndata))),                        length(te_set)), paste0(\"k-\", te_set)) fc_obj <- setNames(rep(list(setNames(vector(mode='list', length=NCOL(vndata)), colnames(vndata))),                        length(te_set)), paste0(\"k-\", te_set))  # ETS model with log transformation ets_log <- function(x, ...){   x[x==0] <- min(x[x!=0])/2   ets(x, lambda = 0, ...) }  for(k in te_set){   idk <- paste0(\"k-\", k)   for(i in 1:NCOL(vndata)){     ids <- colnames(vndata)[i]     model[[idk]][[ids]] <- ets_log(data_k[[idk]][,i])     fc_obj[[idk]][[ids]] <- forecast(model[[idk]][[ids]], h = m/k)   }   cat(k, \" \") } #> 12  6  4  3  2  1 # Point forecasts base <- lapply(fc_obj, function(x) rbind(sapply(x, function(y) y$mean))) str(base, give.attr=FALSE) #> List of 6 #>  $ k-12: num [1, 1:525] 327178 99476 63854 79348 20809 ... #>  $ k-6 : num [1:2, 1:525] 171018 157987 52963 46291 35704 ... #>  $ k-4 : num [1:3, 1:525] 126347 98437 105568 41869 29839 ... #>  $ k-3 : num [1:4, 1:525] 96845 75196 79409 79498 30443 ... #>  $ k-2 : num [1:6, 1:525] 72593 54242 45402 53122 55872 ... #>  $ k-1 : num [1:12, 1:525] 50651 21336 24567 29800 22846 ...  # Residuals res <- lapply(fc_obj, function(x) rbind(sapply(x, residuals, type = \"response\"))) str(res, give.attr=FALSE) #> List of 6 #>  $ k-12: num [1:19, 1:525] 3241 3444 -1935 -4632 8946 ... #>  $ k-6 : num [1:38, 1:525] -140.6 -408 4588.6 -4072.2 -71.5 ... #>  $ k-4 : num [1:57, 1:525] -20.7 19.8 -1219.6 4592.3 -706.1 ... #>  $ k-3 : num [1:76, 1:525] 192 -542 674 -1212 3679 ... #>  $ k-2 : num [1:114, 1:525] -329 -720 -453 538 -693 ... #>  $ k-1 : num [1:228, 1:525] 2143 -970 -115 133 951 ... fc_bts <- t(base$`k-1`[, colnames(vnaggmat)]) rf_bu <- ctbu(fc_bts, agg_order = m, agg_mat = vnaggmat) str(rf_bu, give.attr=FALSE) #>  num [1:525, 1:28] 280206 89744 55472 69366 16847 ... str(FoReco2matrix(rf_bu), give.attr=FALSE) #> List of 6 #>  $ k-12: num [1, 1:525] 280206 89744 55472 69366 16847 ... #>  $ k-6 : num [1:2, 1:525] 147023 133182 48055 41689 31372 ... #>  $ k-4 : num [1:3, 1:525] 108461 82962 88782 36173 25354 ... #>  $ k-3 : num [1:4, 1:525] 82898 64126 66292 66891 27564 ... #>  $ k-2 : num [1:6, 1:525] 62313 46149 38562 44400 46889 ... #>  $ k-1 : num [1:12, 1:525] 44094 18218 20585 25563 19385 ... bts_mat <- data_k$`k-1`[, colnames(vnaggmat)] tot_12 <- data_k$`k-12`[,1] fc_tot_12 <- base$`k-12`[,1]  # Average historical proportions - Gross-Sohl method A p_gsa <- apply(bts_mat, 2, function(y){   colMeans(apply(matrix(y, ncol = m, byrow = TRUE), 2, function(x) x/tot_12)) }) rf_td_gsa <- cttd(fc_tot_12, agg_order = m, weights = t(p_gsa), agg_mat = vnaggmat) str(rf_td_gsa, give.attr=FALSE) #>  num [1:525, 1:28] 327178 105757 63173 85397 22176 ...  # Proportions of the historical averages - Gross-Sohl method F p_gsf <- apply(bts_mat, 2, function(y){   colMeans(matrix(y, ncol = m, byrow = TRUE))/mean(tot_12) }) rf_td_gsf <- cttd(fc_tot_12, agg_order = m, weights = t(p_gsf), agg_mat = vnaggmat) str(rf_td_gsf, give.attr=FALSE) #>  num [1:525, 1:28] 327178 105656 63188 85290 22160 ... base_mat <- t(Reduce(rbind, base)) res_mat <- t(Reduce(rbind, res)) rf_lcc <- ctlcc(base = base_mat, agg_order = m, agg_mat = vnaggmat,                 res = res_mat, comb = \"wlsv\") str(rf_lcc, give.attr=FALSE) #>  num [1:525, 1:28] 316724 98441 62491 79420 19591 ... rf_ite <- iterec(base = base_mat, res = res_mat,                  cslist = list(agg_mat = vnaggmat, comb = \"shr\"),                   telist = list(agg_order = m, comb = \"wlsv\")) #> ── Iterative heuristic cross-temporal forecast reconciliation ────────────────── #> Legend: i = iteration; s = step. Norm = \"inf\". #>  #>   i.s |        Temporal | Cross-sectional | #>     0 |         4869.77 |        23213.13 | #>   1.1 |            0.00 |        34262.16 | #>   1.2 |         6994.71 |            0.00 | #>   2.1 |            0.00 |         1112.59 | #>   2.2 |          342.66 |            0.00 | #>   3.1 |            0.00 |           47.08 | #>   3.2 |           16.48 |            0.00 | #>   4.1 |            0.00 |            2.15 | #>   4.2 |        7.91e-01 |            0.00 | #>   5.1 |            0.00 |        1.01e-01 | #>   5.2 |        3.79e-02 |            0.00 | #>   6.1 |            0.00 |        4.81e-03 | #>   6.2 |        1.81e-03 |            0.00 | #>   7.1 |            0.00 |        2.29e-04 | #>   7.2 |        8.68e-05 |            0.00 | #>   8.1 |            0.00 |        1.10e-05 | #>   8.2 |        4.15e-06 |            0.00 | #>  #> ✔ Convergence achieved at iteration 8. #> ──────────────────────────────────────────────────────────────────────────────── str(rf_ite, give.attr=FALSE) #>  num [1:525, 1:28] 324066 98946 64400 80221 20703 ... rf_tcs <- tcsrec(base = base_mat, res = res_mat,                  cslist = list(agg_mat = vnaggmat, comb = \"shr\"),                   telist = list(agg_order = m, comb = \"wlsv\")) str(rf_tcs, give.attr=FALSE) #>  num [1:525, 1:28] 323553 98861 64315 80090 20660 ... rf_cst <- cstrec(base = base_mat, res = res_mat,                  cslist = list(agg_mat = vnaggmat, comb = \"shr\"),                   telist = list(agg_order = m, comb = \"wlsv\")) str(rf_cst, give.attr=FALSE) #>  num [1:525, 1:28] 324708 99123 64462 80416 20802 ... rf_opt <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                 res = res_mat, comb = \"wlsv\", approach = \"strc\") str(rf_opt, give.attr=FALSE) #>  num [1:525, 1:28] 314297 97383 62631 77793 19695 ... rf_ols <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                 res = res_mat, comb = \"ols\", approach = \"strc\") recoinfo(rf_ols) #> ✔ Optimal Cross-temporal Forecast Reconciliation #> ℹ FoReco function: `ctrec` #> ℹ Covariance approximation: `ols` #> ℹ Non-negative forecasts: `FALSE` rf_osqp <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                   approach = \"strc\", res = res_mat, comb = \"ols\", nn = \"osqp\") tmp <- recoinfo(rf_osqp) #> ✔ Optimal Cross-temporal Forecast Reconciliation #> ℹ FoReco function: `ctrec` #> ℹ Covariance approximation: `ols` #> ℹ Non-negative forecasts: `TRUE` tmp$info # OSQP information matrix  #>         obj_val run_time iter      pri_res status status_polish #> 1 -220421537281 77.36823 1050 1.052998e-21      1             1 rf_sntz <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                  approach = \"strc\", res = res_mat, comb = \"ols\", nn = \"sntz\") recoinfo(rf_sntz) #> ✔ Optimal Cross-temporal Forecast Reconciliation #> ℹ FoReco function: `ctrec` #> ℹ Covariance approximation: `ols` #> ℹ Non-negative forecasts: `TRUE` rf_imm <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat, approach = \"strc\",                 res = res_mat, comb = \"wlsv\", immutable = cbind(2:8, 12, 1)) str(rf_imm, give.attr=FALSE) #>  num [1:525, 1:28] 321957 99476 63854 79348 20809 ... round(rf_imm[2:8,1] - base_mat[2:8,1], 6) #> A B C D E F G  #> 0 0 0 0 0 0 0 te_subset <- c(12, 3, 1) base_mat2 <- t(Reduce(rbind, base[paste0(\"k-\", te_subset)])) res_mat2 <- t(Reduce(rbind, res[paste0(\"k-\", te_subset)])) rf_sub <- ctrec(base = base_mat2, agg_order = te_subset, agg_mat = vnaggmat,                 res = res_mat2, comb = \"wlsv\", approach = \"strc\") str(rf_sub, give.attr=FALSE) #>  num [1:525, 1:17] 313400 97327 62517 77555 19511 ... # Base forecasts' sample B <- 100 # Base forecasts' sample base_ctjb <- ctboot(model, B, agg_order = m)$sample  str(base_ctjb[1:3], give.attr=FALSE) #> List of 3 #>  $ : num [1:525, 1:28] 322620 94800 62004 83040 21827 ... #>  $ : num [1:525, 1:28] 339222 104166 64981 83683 22610 ... #>  $ : num [1:525, 1:28] 324965 99096 65164 77443 22438 ...  reco_ctjb <- ctsample(simplify2array(base_ctjb), agg_order = m, agg_mat = vnaggmat,                       res = res_mat, comb = \"wlsv\", approach = \"strc\", nn = \"sntz\") class(reco_ctjb) # distribution object #> [1] \"distribution\" \"vctrs_vctr\"   \"list\"  # Extracts mean: mean_ctjb <- mean(reco_ctjb) mean_ctjb <- as_ctmatrix(mean_ctjb, agg_order = m,                           n = sum(dim(vnaggmat)),                           row_names = unlist(dimnames(vnaggmat))) str(mean_ctjb, give.attr = FALSE) #>  num [1:525, 1:28] 324441 98533 64895 80703 20289 ... # Gaussian reconciled distribution reco_ctg_wlsv <- ctgauss(base = base_mat, agg_mat = vnaggmat,                           agg_order = m, comb = \"wlsv\", res = res_mat) #> Warning in asMethod(object): sparse->dense coercion: allocating vector of size #> 1.6 GiB reco_ctg_wlsv # distribution object #> <distribution[1]> #>      tao-1  #> MVN[14700]  # Gaussian reconciled distribution with different base covariance matrix # Multi-step residuals hres <- lapply(model, function(fit)   lapply(1:frequency(fit[[1]]$x), function(h)      sapply(fit, residuals, type='response', h = h))) hres_ct <- t(Reduce(\"rbind\", lapply(hres, arrange_hres))) # Re-arrenge multi-step residuals in a matrix form mres <- as_hstack_ctlayout(hres_ct, agg_order = m) # cov_shr <- shrink_estim(na.omit(mres)) # Time and computational intensive to use, but the better one cov_wls <- diag(x = diag(cov(na.omit(mres))))  # Computational intensive: # reco_ctg_wls <- ctgauss(base = base_mat, agg_mat = vnaggmat,  #                         agg_order = m, comb = \"wlsv\", res = res_mat,  #                         comb_base = cov_wls) # reco_ctg_wls # distribution object  # Reconciled sample distribution starting from Gaussian base forecasts - faster approach base_cts <- GMCM::rmvnormal(B, mu = res2matrix(base_mat, agg_order = m),                              sigma = cov_wls) #> Warning: `res2matrix()` was deprecated in FoReco 1.0. #> ℹ Please use `FoReco::as_hstack_telayout()` or `FoReco::as_hstack_ctlayout()`. base_cts <- apply(base_cts, 1, as_ctmatrix, agg_order = m,                    n = sum(dim(vnaggmat)),                   row_names = unlist(dimnames(vnaggmat)),                   simplify = FALSE) base_cts <- simplify2array(base_cts) reco_cts <- ctsample(base_cts, agg_order = m, agg_mat = vnaggmat,                      res = res_mat, comb = \"wlsv\", approach = \"strc\", nn = \"sntz\") reco_cts # distribution object #> <distribution[1]> #>       tao-1  #> sample[100]"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"base-forecast","dir":"Articles","previous_headings":"","what":"Base forecast","title":"Cross-temporal forecast reconciliation","text":"obtained base forecasts, fit ETS model log transformation series. handle zeros replacing half minimum non-zero value series (Wickramasuriya et al., 2020), fit ETS model generate forecasts. obtain twelve-, six-, four-, three-, two-, one-step-ahead base forecasts monthly data aggregation 2, 3, 4, 6, 12 months. extract point forecasts residuals fitted models.","code":"te_set <- tetools(12)$set m <- max(te_set) data_k <- aggts(vndata, te_set) model <- setNames(rep(list(setNames(vector(mode='list', length=NCOL(vndata)), colnames(vndata))),                        length(te_set)), paste0(\"k-\", te_set)) fc_obj <- setNames(rep(list(setNames(vector(mode='list', length=NCOL(vndata)), colnames(vndata))),                        length(te_set)), paste0(\"k-\", te_set))  # ETS model with log transformation ets_log <- function(x, ...){   x[x==0] <- min(x[x!=0])/2   ets(x, lambda = 0, ...) }  for(k in te_set){   idk <- paste0(\"k-\", k)   for(i in 1:NCOL(vndata)){     ids <- colnames(vndata)[i]     model[[idk]][[ids]] <- ets_log(data_k[[idk]][,i])     fc_obj[[idk]][[ids]] <- forecast(model[[idk]][[ids]], h = m/k)   }   cat(k, \" \") } #> 12  6  4  3  2  1 # Point forecasts base <- lapply(fc_obj, function(x) rbind(sapply(x, function(y) y$mean))) str(base, give.attr=FALSE) #> List of 6 #>  $ k-12: num [1, 1:525] 327178 99476 63854 79348 20809 ... #>  $ k-6 : num [1:2, 1:525] 171018 157987 52963 46291 35704 ... #>  $ k-4 : num [1:3, 1:525] 126347 98437 105568 41869 29839 ... #>  $ k-3 : num [1:4, 1:525] 96845 75196 79409 79498 30443 ... #>  $ k-2 : num [1:6, 1:525] 72593 54242 45402 53122 55872 ... #>  $ k-1 : num [1:12, 1:525] 50651 21336 24567 29800 22846 ...  # Residuals res <- lapply(fc_obj, function(x) rbind(sapply(x, residuals, type = \"response\"))) str(res, give.attr=FALSE) #> List of 6 #>  $ k-12: num [1:19, 1:525] 3241 3444 -1935 -4632 8946 ... #>  $ k-6 : num [1:38, 1:525] -140.6 -408 4588.6 -4072.2 -71.5 ... #>  $ k-4 : num [1:57, 1:525] -20.7 19.8 -1219.6 4592.3 -706.1 ... #>  $ k-3 : num [1:76, 1:525] 192 -542 674 -1212 3679 ... #>  $ k-2 : num [1:114, 1:525] -329 -720 -453 538 -693 ... #>  $ k-1 : num [1:228, 1:525] 2143 -970 -115 133 951 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"point-forecast-reconciliation","dir":"Articles","previous_headings":"","what":"Point forecast reconciliation","title":"Cross-temporal forecast reconciliation","text":"Within FoReco, range reconciliation strategies available, including bottom-, top-, level conditional coherent forecast reconciliation, cross-temporal heuristics. Bottom-reconciliation (Dunn et al., 1976) aggregates high-frequency forecasts lowest cross-sectional level higher cross-temporal levels (Girolimetto et al., 2024). obtain list forecasts different orders aggregation, can use FoReco2matrix function. top-reconciliation hierarchical time series, forecast top-level series (Total) distributed proportionally ensure top-level value stays bottom-level forecasts non-negative (Gross & Sohl, 1990). perform cross-temporal reconciliation FoReco using complete set base forecasts (cross-sectional temporal level), necessary arrange base forecasts (residuals) matrix form. rows matrix represent cross-sectional variables, columns temporal dimension. level conditional coherent reconciliation (LCC) generalization original proposal Hollyman et al. (2021) Di Fonzo & Girolimetto (2024) include cross-temporal framework iterative procedure described Di Fonzo & Girolimetto (2023a) produces cross-temporally reconciled forecasts alternating forecast reconciliation along one single dimension (either cross-sectional temporal) iteration step. cross-temporal method Kourentzes & Athanasopoulos (2019), involves three steps: first, reconciling forecasts time series different temporal aggregation levels using temporal hierarchies; second, performing cross-sectional reconciliation temporal aggregation order; third, averaging projection matrices second step using cross-sectionally reconcile forecasts first step. contrast, can reverses steps starting cross-sectional reconciliation followed temporal reconciliation (Di Fonzo & Girolimetto, 2023a). Finally can obtained optimal (least squares sense) combination cross-temporal reconciled forecast (Di Fonzo & Girolimetto, 2023a; Girolimetto et al., 2024). following table shows options optimal combination cross-temporal reconciliation function ctrec().","code":"fc_bts <- t(base$`k-1`[, colnames(vnaggmat)]) rf_bu <- ctbu(fc_bts, agg_order = m, agg_mat = vnaggmat) str(rf_bu, give.attr=FALSE) #>  num [1:525, 1:28] 280206 89744 55472 69366 16847 ... str(FoReco2matrix(rf_bu), give.attr=FALSE) #> List of 6 #>  $ k-12: num [1, 1:525] 280206 89744 55472 69366 16847 ... #>  $ k-6 : num [1:2, 1:525] 147023 133182 48055 41689 31372 ... #>  $ k-4 : num [1:3, 1:525] 108461 82962 88782 36173 25354 ... #>  $ k-3 : num [1:4, 1:525] 82898 64126 66292 66891 27564 ... #>  $ k-2 : num [1:6, 1:525] 62313 46149 38562 44400 46889 ... #>  $ k-1 : num [1:12, 1:525] 44094 18218 20585 25563 19385 ... bts_mat <- data_k$`k-1`[, colnames(vnaggmat)] tot_12 <- data_k$`k-12`[,1] fc_tot_12 <- base$`k-12`[,1]  # Average historical proportions - Gross-Sohl method A p_gsa <- apply(bts_mat, 2, function(y){   colMeans(apply(matrix(y, ncol = m, byrow = TRUE), 2, function(x) x/tot_12)) }) rf_td_gsa <- cttd(fc_tot_12, agg_order = m, weights = t(p_gsa), agg_mat = vnaggmat) str(rf_td_gsa, give.attr=FALSE) #>  num [1:525, 1:28] 327178 105757 63173 85397 22176 ...  # Proportions of the historical averages - Gross-Sohl method F p_gsf <- apply(bts_mat, 2, function(y){   colMeans(matrix(y, ncol = m, byrow = TRUE))/mean(tot_12) }) rf_td_gsf <- cttd(fc_tot_12, agg_order = m, weights = t(p_gsf), agg_mat = vnaggmat) str(rf_td_gsf, give.attr=FALSE) #>  num [1:525, 1:28] 327178 105656 63188 85290 22160 ... base_mat <- t(Reduce(rbind, base)) res_mat <- t(Reduce(rbind, res)) rf_lcc <- ctlcc(base = base_mat, agg_order = m, agg_mat = vnaggmat,                 res = res_mat, comb = \"wlsv\") str(rf_lcc, give.attr=FALSE) #>  num [1:525, 1:28] 316724 98441 62491 79420 19591 ... rf_ite <- iterec(base = base_mat, res = res_mat,                  cslist = list(agg_mat = vnaggmat, comb = \"shr\"),                   telist = list(agg_order = m, comb = \"wlsv\")) #> ── Iterative heuristic cross-temporal forecast reconciliation ────────────────── #> Legend: i = iteration; s = step. Norm = \"inf\". #>  #>   i.s |        Temporal | Cross-sectional | #>     0 |         4869.77 |        23213.13 | #>   1.1 |            0.00 |        34262.16 | #>   1.2 |         6994.71 |            0.00 | #>   2.1 |            0.00 |         1112.59 | #>   2.2 |          342.66 |            0.00 | #>   3.1 |            0.00 |           47.08 | #>   3.2 |           16.48 |            0.00 | #>   4.1 |            0.00 |            2.15 | #>   4.2 |        7.91e-01 |            0.00 | #>   5.1 |            0.00 |        1.01e-01 | #>   5.2 |        3.79e-02 |            0.00 | #>   6.1 |            0.00 |        4.81e-03 | #>   6.2 |        1.81e-03 |            0.00 | #>   7.1 |            0.00 |        2.29e-04 | #>   7.2 |        8.68e-05 |            0.00 | #>   8.1 |            0.00 |        1.10e-05 | #>   8.2 |        4.15e-06 |            0.00 | #>  #> ✔ Convergence achieved at iteration 8. #> ──────────────────────────────────────────────────────────────────────────────── str(rf_ite, give.attr=FALSE) #>  num [1:525, 1:28] 324066 98946 64400 80221 20703 ... rf_tcs <- tcsrec(base = base_mat, res = res_mat,                  cslist = list(agg_mat = vnaggmat, comb = \"shr\"),                   telist = list(agg_order = m, comb = \"wlsv\")) str(rf_tcs, give.attr=FALSE) #>  num [1:525, 1:28] 323553 98861 64315 80090 20660 ... rf_cst <- cstrec(base = base_mat, res = res_mat,                  cslist = list(agg_mat = vnaggmat, comb = \"shr\"),                   telist = list(agg_order = m, comb = \"wlsv\")) str(rf_cst, give.attr=FALSE) #>  num [1:525, 1:28] 324708 99123 64462 80416 20802 ... rf_opt <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                 res = res_mat, comb = \"wlsv\", approach = \"strc\") str(rf_opt, give.attr=FALSE) #>  num [1:525, 1:28] 314297 97383 62631 77793 19695 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"practical-challenges","dir":"Articles","previous_headings":"","what":"Practical challenges","title":"Cross-temporal forecast reconciliation","text":"always true reconciled forecasts remain non-negative even base forecasts non-negative. example, consider case identity covariance matrix (\"ols\"). address issue, can use two approaches: State---art numerical optimization procedure, osqp (Stellato et al., 2020). Simple heuristic strategy: set-negative--zero, sntz (Di Fonzo & Girolimetto, 2023b). Sometimes may wish incorporate priori knowledge reconciliation process (Zhang et al., 2023) order improve accuracy reconciled forecasts. example, suppose want fix forecasts states level annual series base forecasts values. approaches far involved considering factors \\(m\\) potential aggregation orders. Nevertheless, worth noting also focus given subset factors. example, interested monthly, quarterly annual forecasts.","code":"rf_ols <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                 res = res_mat, comb = \"ols\", approach = \"strc\") recoinfo(rf_ols) #> ✔ Optimal Cross-temporal Forecast Reconciliation #> ℹ FoReco function: `ctrec` #> ℹ Covariance approximation: `ols` #> ℹ Non-negative forecasts: `FALSE` rf_osqp <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                   approach = \"strc\", res = res_mat, comb = \"ols\", nn = \"osqp\") tmp <- recoinfo(rf_osqp) #> ✔ Optimal Cross-temporal Forecast Reconciliation #> ℹ FoReco function: `ctrec` #> ℹ Covariance approximation: `ols` #> ℹ Non-negative forecasts: `TRUE` tmp$info # OSQP information matrix  #>         obj_val run_time iter      pri_res status status_polish #> 1 -220421537281 77.36823 1050 1.052998e-21      1             1 rf_sntz <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                  approach = \"strc\", res = res_mat, comb = \"ols\", nn = \"sntz\") recoinfo(rf_sntz) #> ✔ Optimal Cross-temporal Forecast Reconciliation #> ℹ FoReco function: `ctrec` #> ℹ Covariance approximation: `ols` #> ℹ Non-negative forecasts: `TRUE` rf_imm <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat, approach = \"strc\",                 res = res_mat, comb = \"wlsv\", immutable = cbind(2:8, 12, 1)) str(rf_imm, give.attr=FALSE) #>  num [1:525, 1:28] 321957 99476 63854 79348 20809 ... round(rf_imm[2:8,1] - base_mat[2:8,1], 6) #> A B C D E F G  #> 0 0 0 0 0 0 0 te_subset <- c(12, 3, 1) base_mat2 <- t(Reduce(rbind, base[paste0(\"k-\", te_subset)])) res_mat2 <- t(Reduce(rbind, res[paste0(\"k-\", te_subset)])) rf_sub <- ctrec(base = base_mat2, agg_order = te_subset, agg_mat = vnaggmat,                 res = res_mat2, comb = \"wlsv\", approach = \"strc\") str(rf_sub, give.attr=FALSE) #>  num [1:525, 1:17] 313400 97327 62517 77555 19511 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"non-negativity-issues","dir":"Articles","previous_headings":"vndata: Groupped monthly time series","what":"Non negativity issues","title":"Cross-temporal forecast reconciliation","text":"always true reconciled forecasts remain non-negative even base forecasts non-negative. example, consider case identity covariance matrix (\"ols\"). address issue, can use two approaches: State---art numerical optimization procedure, osqp (Stellato et al., 2020). Simple heuristic strategy: set-negative--zero, sntz (Di Fonzo & Girolimetto, 2023b).","code":"rf_ols <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                 res = res_mat, comb = \"ols\", approach = \"strc\") recoinfo(rf_ols) #> ✔ Optimal Cross-temporal Forecast Reconciliation #> ℹ FoReco function: `ctrec` #> ℹ Covariance approximation: `ols` #> ℹ Non-negative forecasts: `FALSE` rf_osqp <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                   approach = \"strc\", res = res_mat, comb = \"ols\", nn = \"osqp\") tmp <- recoinfo(rf_osqp) #> ✔ Optimal Cross-temporal Forecast Reconciliation #> ℹ FoReco function: `ctrec` #> ℹ Covariance approximation: `ols` #> ℹ Non-negative forecasts: `TRUE` tmp$info # OSQP information matrix  #>         obj_val run_time iter      pri_res status status_polish #> 1 -220421537281 77.36823 1050 1.052998e-21      1             1 rf_sntz <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                  approach = \"strc\", res = res_mat, comb = \"ols\", nn = \"sntz\") recoinfo(rf_sntz) #> ✔ Optimal Cross-temporal Forecast Reconciliation #> ℹ FoReco function: `ctrec` #> ℹ Covariance approximation: `ols` #> ℹ Non-negative forecasts: `TRUE`"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"a-priori-constrained-immutable-forecasts","dir":"Articles","previous_headings":"vndata: Groupped monthly time series","what":"A priori constrained (immutable) forecasts","title":"Cross-temporal forecast reconciliation","text":"Sometimes may wish incorporate priori knowledge reconciliation process (Zhang et al., 2023) order improve accuracy reconciled forecasts. example, suppose want fix forecasts states level annual series base forecasts values.","code":"rf_imm <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat, approach = \"strc\",                 res = res_mat, comb = \"wlsv\", immutable = cbind(2:8, 12, 1)) str(rf_imm, give.attr=FALSE) #>  num [1:525, 1:28] 321957 99476 63854 79348 20809 ... round(rf_imm[2:8,1] - base_mat[2:8,1], 6) #> A B C D E F G  #> 0 0 0 0 0 0 0"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"exploring-a-subset-of-temporal-aggregation-orders","dir":"Articles","previous_headings":"vndata: Groupped monthly time series","what":"Exploring a subset of temporal aggregation orders","title":"Cross-temporal forecast reconciliation","text":"approaches far involved considering factors \\(m\\) potential aggregation orders. Nevertheless, worth noting also focus given subset factors. example, interested monthly, quarterly annual forecasts.","code":"te_subset <- c(12, 3, 1) base_mat2 <- t(Reduce(rbind, base[paste0(\"k-\", te_subset)])) res_mat2 <- t(Reduce(rbind, res[paste0(\"k-\", te_subset)])) rf_sub <- ctrec(base = base_mat2, agg_order = te_subset, agg_mat = vnaggmat,                 res = res_mat2, comb = \"wlsv\", approach = \"strc\") str(rf_sub, give.attr=FALSE) #>  num [1:525, 1:17] 313400 97327 62517 77555 19511 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"probabilistic-forecast-reconciliation","dir":"Articles","previous_headings":"","what":"Probabilistic forecast reconciliation","title":"Cross-temporal forecast reconciliation","text":"Girolimetto et al. (2024) extends cross-temporal framework probabilistic results presented Panagiotelis et al. (2023) cross-sectional reconciliation. reconciliation probabilistic forecasts two-step process: first, sample incoherent distribution, reconcile sample. can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . parametric method assumes normal distribution (Gaussian), generate incoherent sample set forecasts. Since simulate multivariate normal distribution size 14700, use diagonal covariance matrix vignette. However, ’s important note choice result significantly narrow variance reconciled forecasts.","code":"# Base forecasts' sample B <- 100 # Base forecasts' sample base_ctjb <- ctboot(model, B, agg_order = m)$sample  str(base_ctjb[1:3], give.attr=FALSE) #> List of 3 #>  $ : num [1:525, 1:28] 322620 94800 62004 83040 21827 ... #>  $ : num [1:525, 1:28] 339222 104166 64981 83683 22610 ... #>  $ : num [1:525, 1:28] 324965 99096 65164 77443 22438 ...  reco_ctjb <- ctsample(simplify2array(base_ctjb), agg_order = m, agg_mat = vnaggmat,                       res = res_mat, comb = \"wlsv\", approach = \"strc\", nn = \"sntz\") class(reco_ctjb) # distribution object #> [1] \"distribution\" \"vctrs_vctr\"   \"list\"  # Extracts mean: mean_ctjb <- mean(reco_ctjb) mean_ctjb <- as_ctmatrix(mean_ctjb, agg_order = m,                           n = sum(dim(vnaggmat)),                           row_names = unlist(dimnames(vnaggmat))) str(mean_ctjb, give.attr = FALSE) #>  num [1:525, 1:28] 324441 98533 64895 80703 20289 ... # Gaussian reconciled distribution reco_ctg_wlsv <- ctgauss(base = base_mat, agg_mat = vnaggmat,                           agg_order = m, comb = \"wlsv\", res = res_mat) #> Warning in asMethod(object): sparse->dense coercion: allocating vector of size #> 1.6 GiB reco_ctg_wlsv # distribution object #> <distribution[1]> #>      tao-1  #> MVN[14700]  # Gaussian reconciled distribution with different base covariance matrix # Multi-step residuals hres <- lapply(model, function(fit)   lapply(1:frequency(fit[[1]]$x), function(h)      sapply(fit, residuals, type='response', h = h))) hres_ct <- t(Reduce(\"rbind\", lapply(hres, arrange_hres))) # Re-arrenge multi-step residuals in a matrix form mres <- as_hstack_ctlayout(hres_ct, agg_order = m) # cov_shr <- shrink_estim(na.omit(mres)) # Time and computational intensive to use, but the better one cov_wls <- diag(x = diag(cov(na.omit(mres))))  # Computational intensive: # reco_ctg_wls <- ctgauss(base = base_mat, agg_mat = vnaggmat,  #                         agg_order = m, comb = \"wlsv\", res = res_mat,  #                         comb_base = cov_wls) # reco_ctg_wls # distribution object  # Reconciled sample distribution starting from Gaussian base forecasts - faster approach base_cts <- GMCM::rmvnormal(B, mu = res2matrix(base_mat, agg_order = m),                              sigma = cov_wls) #> Warning: `res2matrix()` was deprecated in FoReco 1.0. #> ℹ Please use `FoReco::as_hstack_telayout()` or `FoReco::as_hstack_ctlayout()`. base_cts <- apply(base_cts, 1, as_ctmatrix, agg_order = m,                    n = sum(dim(vnaggmat)),                   row_names = unlist(dimnames(vnaggmat)),                   simplify = FALSE) base_cts <- simplify2array(base_cts) reco_cts <- ctsample(base_cts, agg_order = m, agg_mat = vnaggmat,                      res = res_mat, comb = \"wlsv\", approach = \"strc\", nn = \"sntz\") reco_cts # distribution object #> <distribution[1]> #>       tao-1  #> sample[100]"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"itagdp-general-linearly-constrained-multiple-quarterly-time-series","dir":"Articles","previous_headings":"","what":"itagdp: general linearly constrained multiple quarterly time series","title":"Cross-temporal forecast reconciliation","text":"section, work itagdp dataset corresponding zero-constrained matrix gdpconsmat. dataset illustrates reconciliation complex linear constraints unique aggregation available. See dataset vignette details. fit ARIMA models series generate base forecasts. data quarterly multivariate time series obtain four-, two-, one-step-ahead base forecasts quarterly data aggregation 2, 4 quarters. apply optimal reconciliation method base forecasts, considering linear constraints defined gdpconsmat. case, want fix forecasts top level series (\\(GDP\\)) annual temporally aggreated series (\\(k = 4\\)) base forecasts values. can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . Alternatively, can use parametric method.","code":"data(itagdp)      # dataset data(gdpconsmat)    # Agg mat matrix te_set <- tetools(4)$set m <- max(te_set) data_k <- aggts(itagdp, te_set) model <- setNames(rep(list(setNames(vector(mode='list', length=NCOL(itagdp)), colnames(itagdp))),                        length(te_set)), paste0(\"k-\", te_set)) fc_obj <- setNames(rep(list(setNames(vector(mode='list', length=NCOL(itagdp)), colnames(itagdp))),                        length(te_set)), paste0(\"k-\", te_set))  for(k in te_set){   idk <- paste0(\"k-\", k)   for(i in 1:NCOL(itagdp)){     ids <- colnames(itagdp)[i]     model[[idk]][[ids]] <- ets(data_k[[idk]][,i])     fc_obj[[idk]][[ids]] <- forecast(model[[idk]][[ids]], h = m/k)   }   cat(k, \" \") } #> 4  2  1 # Point forecasts base <- lapply(fc_obj, function(x) rbind(sapply(x, function(y) y$mean))) str(base, give.attr = FALSE) #> List of 3 #>  $ k-4: num [1, 1:21] 1811793 736509 1748222 1421782 326061 ... #>  $ k-2: num [1:2, 1:21] 884015 928287 351866 379716 855453 ... #>  $ k-1: num [1:4, 1:21] 431993 451829 449546 480841 167984 ...  # Residuals res <- lapply(fc_obj, function(x) rbind(sapply(x, residuals, type = \"response\"))) str(res, give.attr = FALSE) #> List of 3 #>  $ k-4: num [1:20, 1:21] -45068 22792 8057 8051 22851 ... #>  $ k-2: num [1:40, 1:21] -14138 421 9758 -4257 2225 ... #>  $ k-1: num [1:80, 1:21] -2778 -1745 -448 4068 3088 ... base_mat <- t(Reduce(rbind, base)) res_mat <- t(Reduce(rbind, res)) rf_opt <- ctrec(base = base_mat, agg_order = m, cons_mat = gdpconsmat,                 res = res_mat, comb = \"bdshr\") str(rf_opt, give.attr = FALSE) #>  num [1:21, 1:7] 1807755 730746 1739243 1417381 321862 ... rf_imm <- ctrec(base = base_mat, agg_order = m, cons_mat = gdpconsmat,                 res = res_mat, comb = \"wlsv\", immutable = rbind(c(1,4,1))) str(rf_imm, give.attr = FALSE) #>  num [1:21, 1:7] 1811793 731220 1743712 1418685 325027 ... rf_imm[1,1] - base_mat[1,1] #> GDP  #>   0 # Base forecasts' sample B <- 100 # Base forecasts' sample base_ctjb <- ctboot(model, B, agg_order = m)$sample  str(base_ctjb[1:3], give.attr=FALSE) #> List of 3 #>  $ : num [1:21, 1:7] 1817775 733629 1741313 1417524 323943 ... #>  $ : num [1:21, 1:7] 1773577 731082 1692280 1385844 307399 ... #>  $ : num [1:21, 1:7] 1848176 737534 1777131 1435378 343570 ...  reco_ctjb <- ctsample(simplify2array(base_ctjb), agg_order = m, cons_mat = gdpconsmat,                       res = res_mat, comb = \"wlsv\") reco_ctjb # distribution object #> <distribution[1]> #>       tao-1  #> sample[100]  # Extracts mean: mean_ctjb <- mean(reco_ctjb) mean_ctjb <- as_ctmatrix(mean_ctjb, agg_order = m,                           n = NCOL(gdpconsmat),                           row_names = colnames(gdpconsmat)) str(mean_ctjb, give.attr = FALSE) #>  num [1:21, 1:7] 1810945 732429 1739876 1415571 324305 ... # Gaussian reconciled distribution reco_ctg_wlsv <- ctgauss(base = base_mat, cons_mat = gdpconsmat,                          agg_order = m, comb = \"wlsv\", res = res_mat) reco_ctg_wlsv # distribution object #> <distribution[1]> #>    tao-1  #> MVN[147]  # Gaussian reconciled distribution with different base covariance matrix # Multi-step residuals hres <- lapply(model, function(fit)   lapply(1:frequency(fit[[1]]$x), function(h)      sapply(fit, residuals, type='response', h = h))) hres_ct <- t(Reduce(\"rbind\", lapply(hres, arrange_hres))) # Re-arrenge multi-step residuals in a matrix form mres <- as_hstack_ctlayout(hres_ct, agg_order = m) # cov_shr <- shrink_estim(na.omit(mres)) # Time and computational intensive to use, but the better one cov_wls <- diag(x = diag(cov(na.omit(mres))))  reco_ctg_wls <- ctgauss(base = base_mat, cons_mat = gdpconsmat,                         agg_order = m, comb = \"wlsv\", res = res_mat,                          comb_base = cov_wls) reco_ctg_wls # distribution object #> <distribution[1]> #>    tao-1  #> MVN[147]  # Reconciled sample distribution starting from Gaussian base forecasts - faster approach base_cts <- GMCM::rmvnormal(B, mu = res2matrix(base_mat, agg_order = m),                              sigma = cov_wls) base_cts <- apply(base_cts, 1, as_ctmatrix, agg_order = m,                    n = NCOL(gdpconsmat),                    row_names = colnames(gdpconsmat),                   simplify = FALSE) base_cts <- simplify2array(base_cts) reco_cts <- ctsample(base_cts, agg_order = m, cons_mat = gdpconsmat,                      res = res_mat, comb = \"wlsv\") reco_cts # distribution object #> <distribution[1]> #>       tao-1  #> sample[100]"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"base-forecast-1","dir":"Articles","previous_headings":"","what":"Base forecast","title":"Cross-temporal forecast reconciliation","text":"fit ARIMA models series generate base forecasts. data quarterly multivariate time series obtain four-, two-, one-step-ahead base forecasts quarterly data aggregation 2, 4 quarters.","code":"te_set <- tetools(4)$set m <- max(te_set) data_k <- aggts(itagdp, te_set) model <- setNames(rep(list(setNames(vector(mode='list', length=NCOL(itagdp)), colnames(itagdp))),                        length(te_set)), paste0(\"k-\", te_set)) fc_obj <- setNames(rep(list(setNames(vector(mode='list', length=NCOL(itagdp)), colnames(itagdp))),                        length(te_set)), paste0(\"k-\", te_set))  for(k in te_set){   idk <- paste0(\"k-\", k)   for(i in 1:NCOL(itagdp)){     ids <- colnames(itagdp)[i]     model[[idk]][[ids]] <- ets(data_k[[idk]][,i])     fc_obj[[idk]][[ids]] <- forecast(model[[idk]][[ids]], h = m/k)   }   cat(k, \" \") } #> 4  2  1 # Point forecasts base <- lapply(fc_obj, function(x) rbind(sapply(x, function(y) y$mean))) str(base, give.attr = FALSE) #> List of 3 #>  $ k-4: num [1, 1:21] 1811793 736509 1748222 1421782 326061 ... #>  $ k-2: num [1:2, 1:21] 884015 928287 351866 379716 855453 ... #>  $ k-1: num [1:4, 1:21] 431993 451829 449546 480841 167984 ...  # Residuals res <- lapply(fc_obj, function(x) rbind(sapply(x, residuals, type = \"response\"))) str(res, give.attr = FALSE) #> List of 3 #>  $ k-4: num [1:20, 1:21] -45068 22792 8057 8051 22851 ... #>  $ k-2: num [1:40, 1:21] -14138 421 9758 -4257 2225 ... #>  $ k-1: num [1:80, 1:21] -2778 -1745 -448 4068 3088 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"point-forecast-reconciliation-1","dir":"Articles","previous_headings":"","what":"Point forecast reconciliation","title":"Cross-temporal forecast reconciliation","text":"apply optimal reconciliation method base forecasts, considering linear constraints defined gdpconsmat. case, want fix forecasts top level series (\\(GDP\\)) annual temporally aggreated series (\\(k = 4\\)) base forecasts values.","code":"base_mat <- t(Reduce(rbind, base)) res_mat <- t(Reduce(rbind, res)) rf_opt <- ctrec(base = base_mat, agg_order = m, cons_mat = gdpconsmat,                 res = res_mat, comb = \"bdshr\") str(rf_opt, give.attr = FALSE) #>  num [1:21, 1:7] 1807755 730746 1739243 1417381 321862 ... rf_imm <- ctrec(base = base_mat, agg_order = m, cons_mat = gdpconsmat,                 res = res_mat, comb = \"wlsv\", immutable = rbind(c(1,4,1))) str(rf_imm, give.attr = FALSE) #>  num [1:21, 1:7] 1811793 731220 1743712 1418685 325027 ... rf_imm[1,1] - base_mat[1,1] #> GDP  #>   0"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"practical-challenge-immutable-forecast","dir":"Articles","previous_headings":"itagdp: general linearly constrained multiple quarterly time series","what":"Practical challenge: immutable forecast","title":"Cross-temporal forecast reconciliation","text":"case, want fix forecasts top level series (\\(GDP\\)) annual temporally aggreated series (\\(k = 4\\)) base forecasts values.","code":"rf_imm <- ctrec(base = base_mat, agg_order = m, cons_mat = gdpconsmat,                 res = res_mat, comb = \"wlsv\", immutable = rbind(c(1,4,1))) str(rf_imm, give.attr = FALSE) #>  num [1:21, 1:7] 1811793 731220 1743712 1418685 325027 ... rf_imm[1,1] - base_mat[1,1] #> GDP  #>   0"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"probabilistic-forecast-reconciliation-1","dir":"Articles","previous_headings":"","what":"Probabilistic forecast reconciliation","title":"Cross-temporal forecast reconciliation","text":"can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . Alternatively, can use parametric method.","code":"# Base forecasts' sample B <- 100 # Base forecasts' sample base_ctjb <- ctboot(model, B, agg_order = m)$sample  str(base_ctjb[1:3], give.attr=FALSE) #> List of 3 #>  $ : num [1:21, 1:7] 1817775 733629 1741313 1417524 323943 ... #>  $ : num [1:21, 1:7] 1773577 731082 1692280 1385844 307399 ... #>  $ : num [1:21, 1:7] 1848176 737534 1777131 1435378 343570 ...  reco_ctjb <- ctsample(simplify2array(base_ctjb), agg_order = m, cons_mat = gdpconsmat,                       res = res_mat, comb = \"wlsv\") reco_ctjb # distribution object #> <distribution[1]> #>       tao-1  #> sample[100]  # Extracts mean: mean_ctjb <- mean(reco_ctjb) mean_ctjb <- as_ctmatrix(mean_ctjb, agg_order = m,                           n = NCOL(gdpconsmat),                           row_names = colnames(gdpconsmat)) str(mean_ctjb, give.attr = FALSE) #>  num [1:21, 1:7] 1810945 732429 1739876 1415571 324305 ... # Gaussian reconciled distribution reco_ctg_wlsv <- ctgauss(base = base_mat, cons_mat = gdpconsmat,                          agg_order = m, comb = \"wlsv\", res = res_mat) reco_ctg_wlsv # distribution object #> <distribution[1]> #>    tao-1  #> MVN[147]  # Gaussian reconciled distribution with different base covariance matrix # Multi-step residuals hres <- lapply(model, function(fit)   lapply(1:frequency(fit[[1]]$x), function(h)      sapply(fit, residuals, type='response', h = h))) hres_ct <- t(Reduce(\"rbind\", lapply(hres, arrange_hres))) # Re-arrenge multi-step residuals in a matrix form mres <- as_hstack_ctlayout(hres_ct, agg_order = m) # cov_shr <- shrink_estim(na.omit(mres)) # Time and computational intensive to use, but the better one cov_wls <- diag(x = diag(cov(na.omit(mres))))  reco_ctg_wls <- ctgauss(base = base_mat, cons_mat = gdpconsmat,                         agg_order = m, comb = \"wlsv\", res = res_mat,                          comb_base = cov_wls) reco_ctg_wls # distribution object #> <distribution[1]> #>    tao-1  #> MVN[147]  # Reconciled sample distribution starting from Gaussian base forecasts - faster approach base_cts <- GMCM::rmvnormal(B, mu = res2matrix(base_mat, agg_order = m),                              sigma = cov_wls) base_cts <- apply(base_cts, 1, as_ctmatrix, agg_order = m,                    n = NCOL(gdpconsmat),                    row_names = colnames(gdpconsmat),                   simplify = FALSE) base_cts <- simplify2array(base_cts) reco_cts <- ctsample(base_cts, agg_order = m, cons_mat = gdpconsmat,                      res = res_mat, comb = \"wlsv\") reco_cts # distribution object #> <distribution[1]> #>       tao-1  #> sample[100]"},{"path":[]},{"path":"https://danigiro.github.io/FoReco/articles/Dataset-vndata-and-itagdp.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The vndata and itagdp dataset","text":"Load packages:","code":"library(FoReco) # the datasets  # Plot and analysis library(ggplot2)  library(forecast)  library(gridExtra) library(reshape2)"},{"path":"https://danigiro.github.io/FoReco/articles/Dataset-vndata-and-itagdp.html","id":"vndata-groupped-monthly-time-series","dir":"Articles","previous_headings":"","what":"vndata: Groupped monthly time series","title":"The vndata and itagdp dataset","text":"Australian Tourism Demand cross-sectional temporal structure Australian Tourism Demand dataset (Girolimetto et al., 2024; Wickramasuriya et al., 2018) measures number nights Australians spent away home. includes 228 monthly observations Visitor Nights (VNs) January 1998 December 2016, cross-sectional grouped structure based geographic hierarchy crossed purpose travel. monthly bottom times series available robjhyndman.com/data/TourismData_v3.csv.  geographic hierarchy comprises 7 states, 27 zones, 76 regions, total 111 nested geographic divisions. Six zones formed single region, resulting 105 unique nodes hierarchy. purpose travel comprises four categories: holiday, visiting friends relatives, business, . avoid redundancies (Di Fonzo & Girolimetto, 2024), 24 nodes (6 zones formed single region) considered, resulting unbalanced hierarchy 525 unique nodes instead theoretical 555 duplicated nodes. data can temporally aggregated two, three, four, six, twelve months (\\(\\mathcal{K}=\\{12, 6, 4, 3, 2, 1\\}\\)). Figure 1: simple unbalanced hierarchy (left) balanced version (right). Source: Di Fonzo & Girolimetto (2024).","code":"# Dataset data(vndata)  str(vndata) #>  Time-Series [1:228, 1:525] from 1998 to 2017: 45151 17295 20725 25389 20330 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:525] \"Total\" \"A\" \"B\" \"C\" ...  # Aggregation matrix data(vnaggmat) str(vnaggmat) #>  int [1:221, 1:304] 1 1 0 0 0 0 0 0 1 0 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : chr [1:221] \"Total\" \"A\" \"B\" \"C\" ... #>   ..$ : chr [1:304] \"AAAHol\" \"AAAVis\" \"AAABus\" \"AAAOth\" ...  id_bts <- colnames(vnaggmat)[round(seq(1, NCOL(vnaggmat), length.out = 10))] states <- c(\"NSW\", \"VIC\", \"QLD\", \"SA\", \"WA\", \"TAS\", \"NT\") colnames(vndata)[colnames(vndata) %in% LETTERS[1:7]] <- states  marrangeGrob(list(autoplot(vndata[,\"Total\"], y = NULL,           main = \"Australia (total)\") + theme_minimal(), autoplot(vndata[, states], y = NULL,           main = \"States\") + theme_minimal(), autoplot(vndata[, c(\"Hol\", \"Vis\", \"Bus\", \"Oth\")], y = NULL,           main = \"Purpose of travel\") + theme_minimal(), autoplot(vndata[,id_bts], y = NULL,           main = \"Bottom time series\") + theme_minimal()),               top = NULL, nrow = 2, ncol = 2)"},{"path":"https://danigiro.github.io/FoReco/articles/Dataset-vndata-and-itagdp.html","id":"itagdp-general-linearly-constrained-multiple-quarterly-time-series","dir":"Articles","previous_headings":"","what":"itagdp: general linearly constrained multiple quarterly time series","title":"The vndata and itagdp dataset","text":"National Accounts coherent consistent set macroeconomic indicators used mostly economic research forecasting, policy design, coordination mechanisms. dataset, GDP key macroeconomic quantity measured using three main approaches, namely output (production), income expenditure. parallel systems internally present well-defned hierarchical structure variables relevant economic signifcance, Final consumption, expenditure side, Gross operating surplus mixed income income side, Total gross value added output side. EU countries, data processed basis ESA 2010 classifcation released Eurostat. dataset itagdp (https://ec.europa.eu/eurostat/web/national-accounts/) contains Italian Gross Domestic Product (GDP) current prices (euro), time series spanning period 2000:Q1-2019:Q4.  output, income expenditure approaches represented three differente hierarchies share top-level series (\\(GDP\\)), bottom-level series.  complete \\((9 \\times 21)\\) zero constraints matrix encompassing output, expenditure income sides represented following figure.  linear combination matrix general linearly constrained multiple time series may construct (Girolimetto & Di Fonzo, 2023).","code":"# Dataset data(itagdp)  str(itagdp) #>  Time-Series [1:80, 1:21] from 2000 to 2020: 290847 309761 301049 339856 307934 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:21] \"GDP\" \"D1\" \"P3_P5\" \"P3\" ... autoplot(itagdp, y = NULL) + theme_minimal() plot_mat <- function(mat, font_size = 8, caption_label = NULL){     melt(mat) |>     ggplot(aes(x = Var2, y = Var1)) +      geom_tile(aes(fill=as.character(value)), color = \"grey\") +      scale_fill_manual(values = c(\"-1\" = \"red\", \"0\" = \"white\", \"1\" = \"black\")) +     labs(x=NULL, y=NULL, title=NULL) +     scale_y_discrete(limits=rev) +      scale_x_discrete(position = \"top\") +     labs(caption = caption_label) +     coord_fixed() +      theme_void() +     theme(axis.text.x=element_text(size=font_size, vjust=0.5, angle = 90, hjust=0),           axis.text.y=element_text(size=font_size, hjust=1),            plot.caption = element_text(size=rel(0.9), hjust=0.5, face = \"bold\"),           legend.position = \"none\")  } marrangeGrob(list(plot_mat(incside$agg_mat, caption_label = \"Income hierarchy\"),                   plot_mat(outside$agg_mat, caption_label = \"Output hierarchy\"),                    plot_mat(expside$agg_mat, caption_label = \"Expenditure hierarchy\")),               top = NULL, layout_matrix = matrix(c(1, 2, 3, 3, 3, 3, 3,3), 2, 4)) rownames(gdpconsmat)[c(1,2,4)] <- c(\"GDP[O]\", \"GDP[I]\", \"GDP[E]\") rownames(gdpconsmat)[-c(1,2,4)] <- colnames(gdpconsmat)[2:7]  plot_mat(gdpconsmat) obj <- lcmat(gdpconsmat)  A <- obj$agg_mat plot_mat(as.matrix(A), caption_label = \"Income, Output and Expenditure linear combination matrix\")"},{"path":[]},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-hts-package.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Replicate the hts package","text":"vignette, htseg2 dataset (simulated four level hierarchy total 17 series, length 16) hts package used show get results using FoReco.","code":"library(FoReco) library(hts)"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-hts-package.html","id":"base-forecasts","dir":"Articles","previous_headings":"","what":"Base forecasts","title":"Replicate the hts package","text":"","code":"data <- allts(htseg2) n <- NCOL(data) nb <- NCOL(htseg2$bts) na <- n-nb A <- smatrix(htseg2)[1:na, ] dimnames(A) <- list(colnames(data)[1:na], colnames(data)[-c(1:na)])  # List containing the base forecasts # Forecast horizon: 10 fc_obj <- list() for (i in 1:n) {   fc_obj[[i]] <- forecast(auto.arima(data[, i])) }  # Create the matrix of base forecasts base <- NULL for (i in 1:n) {   base <- cbind(base, fc_obj[[i]]$mean) } colnames(base) <- colnames(data)  # Create the matrix of residuals res <- NULL for (i in 1:n) {   res <- cbind(res, fc_obj[[i]]$residuals) } colnames(res) <- colnames(data)"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-hts-package.html","id":"comparisons","dir":"Articles","previous_headings":"","what":"Comparisons","title":"Replicate the hts package","text":"section compare reconciliation methods available hts FoReco packages show equivalence . explore bottom-, top-, optimal reconciliation approaches.","code":"# Tollerance setting tol <- 1e-7  ## Bottom-up hts_bu <- forecast(htseg2, method = \"bu\", fmethod = \"arima\") FoReco_bu <- csbu(base[, colnames(A)], agg_mat = A) sum(abs(allts(hts_bu) - FoReco_bu) > tol) #> [1] 0  ## Top-down  ### Average historical proportions - Gross-Sohl method A hts_gsa <- forecast(htseg2, method = \"tdgsa\", fmethod = \"arima\") p_gsa <- colMeans(apply(htseg2$bts, 2, function(x) x/rowSums(htseg2$bts))) FoReco_gsa <- cstd(base[, 1], agg_mat = A, weights = p_gsa) sum(abs(allts(hts_gsa) - FoReco_gsa) > tol) #> [1] 0  ## Proportions of the historical averages - Gross-Sohl method F hts_gsf <- forecast(htseg2, method = \"tdgsf\", fmethod = \"arima\") p_gsf <- colMeans(htseg2$bts)/mean(rowSums(htseg2$bts)) FoReco_gsf <- cstd(base[, 1], agg_mat = A, weights = p_gsf) sum(abs(allts(hts_gsf) - FoReco_gsf) > tol) #> [1] 0  ### Forecast proportions hts_fp <- forecast(htseg2, method = \"tdfp\", fmethod = \"arima\") # FoReco needs the forecast proportions as input levels <- c(1, 2, 4, 10) S <- cstools(A)$strc_mat p_fp <- matrix(NA, nrow = NROW(base), ncol = NCOL(S)) for(i in 1:NROW(base)){   idl <- rep(1:length(levels), levels)   for(j in 1:NCOL(S)){     cs <- S[, j]     id2 <- rev(which(cs==1))     out <- NULL     for(k in 1:length(id2[-1])){       tmp <- S[which(idl == idl[id2[k]]-1), , drop = FALSE]       idf <- rowSums(S[idl == idl[id2[k]], tmp[tmp[,j]==1, ] == 1, drop = FALSE]) != 0       out <- c(out, base[i, id2[k]]/sum(sum(base[i, idl == idl[id2[k]]][idf])))     }     p_fp[i, j] <- prod(out)   } } FoReco_fp <- cstd(base[, 1], agg_mat = A, weights = p_fp, normalize = F) #> Warning: The `weights` do not add up to 1 sum(abs(allts(hts_fp) - FoReco_fp) > tol) #> [1] 0 ## Ordinary least squares (identity error covariance matrix) hts_ols <- combinef(base, nodes = get_nodes(htseg2), keep = \"all\") FoReco_ols <- csrec(base, agg_mat = A, comb = \"ols\") sum(abs(hts_ols - FoReco_ols) > tol) #> [1] 0  ## Weighted least squares (structural variances) hts_str <- combinef(base, nodes = get_nodes(htseg2),                      weights = 1/apply(smatrix(htseg2), 1, sum),                      keep = \"all\") FoReco_str <- csrec(base, agg_mat = A, comb = \"str\") sum(abs(hts_str - FoReco_str) > tol) #> [1] 0  ## Generalized least squares (shrunk covariance matrix) hts_shr <- MinT(base, nodes = get_nodes(htseg2), keep = \"all\",                   covariance = \"shr\", residual = res) FoReco_shr <- csrec(base, agg_mat = A, comb = \"shr\", res = res) sum(abs(hts_shr - FoReco_shr) > tol) #> [1] 0  ## Generalized least squares (sample covariance matrix) hts_sam <- MinT(base, nodes = get_nodes(htseg2), keep = \"all\",                   covariance = \"sam\", residual = res) #> Warning in value[[3L]](cond): An error in LU decomposition occurred, the message was the following: #> 'a' is computationally singular, min(d)/max(d)=1.13234e-16, d=abs(diag(U)) #>  Trying QR decomposition instead... FoReco_sam <- csrec(base, agg_mat = A, comb = \"sam\", res = res) sum(abs(hts_sam-FoReco_sam) > tol) #> [1] 0"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-hts-package.html","id":"bottom-up-and-top-down-reconciliation","dir":"Articles","previous_headings":"","what":"Bottom-up and top-down reconciliation","title":"Replicate the hts package","text":"","code":"# Tollerance setting tol <- 1e-7  ## Bottom-up hts_bu <- forecast(htseg2, method = \"bu\", fmethod = \"arima\") FoReco_bu <- csbu(base[, colnames(A)], agg_mat = A) sum(abs(allts(hts_bu) - FoReco_bu) > tol) #> [1] 0  ## Top-down  ### Average historical proportions - Gross-Sohl method A hts_gsa <- forecast(htseg2, method = \"tdgsa\", fmethod = \"arima\") p_gsa <- colMeans(apply(htseg2$bts, 2, function(x) x/rowSums(htseg2$bts))) FoReco_gsa <- cstd(base[, 1], agg_mat = A, weights = p_gsa) sum(abs(allts(hts_gsa) - FoReco_gsa) > tol) #> [1] 0  ## Proportions of the historical averages - Gross-Sohl method F hts_gsf <- forecast(htseg2, method = \"tdgsf\", fmethod = \"arima\") p_gsf <- colMeans(htseg2$bts)/mean(rowSums(htseg2$bts)) FoReco_gsf <- cstd(base[, 1], agg_mat = A, weights = p_gsf) sum(abs(allts(hts_gsf) - FoReco_gsf) > tol) #> [1] 0  ### Forecast proportions hts_fp <- forecast(htseg2, method = \"tdfp\", fmethod = \"arima\") # FoReco needs the forecast proportions as input levels <- c(1, 2, 4, 10) S <- cstools(A)$strc_mat p_fp <- matrix(NA, nrow = NROW(base), ncol = NCOL(S)) for(i in 1:NROW(base)){   idl <- rep(1:length(levels), levels)   for(j in 1:NCOL(S)){     cs <- S[, j]     id2 <- rev(which(cs==1))     out <- NULL     for(k in 1:length(id2[-1])){       tmp <- S[which(idl == idl[id2[k]]-1), , drop = FALSE]       idf <- rowSums(S[idl == idl[id2[k]], tmp[tmp[,j]==1, ] == 1, drop = FALSE]) != 0       out <- c(out, base[i, id2[k]]/sum(sum(base[i, idl == idl[id2[k]]][idf])))     }     p_fp[i, j] <- prod(out)   } } FoReco_fp <- cstd(base[, 1], agg_mat = A, weights = p_fp, normalize = F) #> Warning: The `weights` do not add up to 1 sum(abs(allts(hts_fp) - FoReco_fp) > tol) #> [1] 0"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-hts-package.html","id":"optimal-forecast-reconciliation","dir":"Articles","previous_headings":"","what":"Optimal forecast reconciliation","title":"Replicate the hts package","text":"","code":"## Ordinary least squares (identity error covariance matrix) hts_ols <- combinef(base, nodes = get_nodes(htseg2), keep = \"all\") FoReco_ols <- csrec(base, agg_mat = A, comb = \"ols\") sum(abs(hts_ols - FoReco_ols) > tol) #> [1] 0  ## Weighted least squares (structural variances) hts_str <- combinef(base, nodes = get_nodes(htseg2),                      weights = 1/apply(smatrix(htseg2), 1, sum),                      keep = \"all\") FoReco_str <- csrec(base, agg_mat = A, comb = \"str\") sum(abs(hts_str - FoReco_str) > tol) #> [1] 0  ## Generalized least squares (shrunk covariance matrix) hts_shr <- MinT(base, nodes = get_nodes(htseg2), keep = \"all\",                   covariance = \"shr\", residual = res) FoReco_shr <- csrec(base, agg_mat = A, comb = \"shr\", res = res) sum(abs(hts_shr - FoReco_shr) > tol) #> [1] 0  ## Generalized least squares (sample covariance matrix) hts_sam <- MinT(base, nodes = get_nodes(htseg2), keep = \"all\",                   covariance = \"sam\", residual = res) #> Warning in value[[3L]](cond): An error in LU decomposition occurred, the message was the following: #> 'a' is computationally singular, min(d)/max(d)=1.13234e-16, d=abs(diag(U)) #>  Trying QR decomposition instead... FoReco_sam <- csrec(base, agg_mat = A, comb = \"sam\", res = res) sum(abs(hts_sam-FoReco_sam) > tol) #> [1] 0"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-thief-package.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Replicate the thief package","text":"dataset AEdemand thief package used show get results FoReco. particular, take weekly data Accident Emergency demand UK, AEdemand, 1 January 2011 31 December 2014.","code":"library(FoReco) library(thief)  extract_thief <- function(x){   out <- NULL   for(i in length(x):1) {     out <- c(out, x[[i]]$mean)   }   return(out) }"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-thief-package.html","id":"base-forecasts","dir":"Articles","previous_headings":"","what":"Base forecasts","title":"Replicate the thief package","text":"","code":"dataset <- window(AEdemand[, 12], start = c(2011, 1), end = c(2014, 52)) data <- tsaggregates(dataset) # Base forecasts fc_obj <- list() for (i in 1:5) {   fc_obj[[i]] <- forecast(auto.arima(data[[i]])) } fc_obj[[6]] <- forecast(auto.arima(data[[6]]), h = 2) # Base forecasts vector base <- NULL for (i in 6:1) {   base <- c(base, fc_obj[[i]]$mean) } # Residual vector res <- NULL for (i in 6:1) {   res <- c(res, fc_obj[[i]]$residuals) }"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-thief-package.html","id":"comparisons","dir":"Articles","previous_headings":"","what":"Comparisons","title":"Replicate the thief package","text":"","code":"# Tollerance setting tol <- 1e-7  ## Bottom-up thief_bu <- reconcilethief(fc_obj, comb=\"bu\") FoReco_bu <- tebu(fc_obj[[1]]$mean, agg_order = 52) sum(abs(FoReco_bu - extract_thief(thief_bu)) > tol) #> [1] 0  ## Ordinary least squares (identity error covariance matrix) thief_ols <- reconcilethief(fc_obj, comb=\"ols\") FoReco_ols <- terec(base, 52, comb = \"ols\") sum(abs(FoReco_ols - extract_thief(thief_ols)) > tol) #> [1] 0  ## Weighted least squares (structural variances) thief_str <- reconcilethief(fc_obj, comb=\"struc\") FoReco_str <- terec(base, 52, comb = \"str\") sum(abs(FoReco_str - extract_thief(thief_str)) > tol) #> [1] 0  ## Generalized least squares (shrunk covariance matrix) thief_shr <- reconcilethief(fc_obj, comb=\"shr\") FoReco_shr <- terec(base, 52, comb = \"shr\", res = res) sum(abs(FoReco_shr - extract_thief(thief_shr)) > tol) #> [1] 0"},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Temporal forecast reconciliation","text":"vignette, explore process temporal reconciliation using FoReco package, focus Capital Country monthly time series (ADB) vndata dataset (Wickramasuriya et al., 2018). Temporal reconciliation method used ensure forecasts coherent across different time periods, providing consistent view high-frequency (e.g., monthly) aggregated levels (e.g., yearly). first obtain base forecasts using ETS model log transformation proceed several reconciliation methods: bottom-, top-, optimal combination. method strengths practical challenges, ensuring non-negativity incorporating priori constraints. First, load necessary packages.","code":"library(FoReco)   # -> To perform reconciliation library(forecast)  # -> To obtain base forecasts"},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"packages","dir":"Articles","previous_headings":"","what":"Packages","title":"Temporal forecast reconciliation","text":"First, load necessary packages.","code":"library(FoReco)   # -> To perform reconciliation library(forecast)  # -> To obtain base forecasts"},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"capital-country-monthly-time-series","dir":"Articles","previous_headings":"","what":"Capital Country monthly time series","title":"Temporal forecast reconciliation","text":"temporal framework, working single series. particular vignette consider Capital Country monthly time series (ADB) vndata dataset (Wickramasuriya et al., 2018). See dataset vignette details. obtained base forecasts, fit ETS model log transformation. obtain twelve-, six-, four-, three-, two-, one-step-ahead base forecasts monthly data aggregation 2, 3, 4, 6, 12 months. extract point forecasts residuals fitted models. Bottom-reconciliation (Dunn et al., 1976) aggregates high-frequency forecasts monthly level higher temporal levels (Girolimetto et al., 2024). obtain list forecasts different orders aggregation, can use FoReco2matrix function. top-reconciliation hierarchical time series, forecast annual series (\\(k = 12\\)) distributed proportionally ensure top-level value stays bottom-level forecasts non-negative (Gross & Sohl, 1990). perform temporal reconciliation FoReco using base forecasts temporal aggregation order, necessary arrange base forecasts (residuals) vector form. level conditional coherent reconciliation (LCC) generalization original proposal Hollyman et al. (2021) Di Fonzo & Girolimetto (2024) include temporal framework. Finally can obtained optimal (least squares sense) combination temporal reconciled forecast (Athanasopoulos et al., 2017). following table shows options optimal combination temporal reconciliation function terec(). always true reconciled forecasts remain non-negative even base forecasts non-negative. example, consider case shrinkage covariance matrix (\"shr\"). address issue, can use two approaches: State---art numerical optimization procedure, osqp (Stellato et al., 2020). Simple heuristic strategy: set-negative--zero, sntz (Di Fonzo & Girolimetto, 2023). Sometimes may wish incorporate priori knowledge reconciliation process (Zhang et al., 2023) order improve accuracy reconciled forecasts. example, suppose want fix forecasts annual level base forecasts values. approaches far involved considering factors \\(m\\) potential aggregation orders. Nevertheless, worth noting also focus given subset factors. example, interested monthly, quarterly annual forecasts. Following Panagiotelis et al. (2023) Girolimetto et al. (2024), reconciliation probabilistic forecasts two-step process: first, sample incoherent distributio, reconcile sample. can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . parametric method assumes normal distribution (Gaussian) generate incoherent sample set forecasts.","code":"data(vndata)      # dataset y <- vndata[, \"GBDOth\"] te_set <- tetools(12)$set m <- max(te_set) data_k <- aggts(y, te_set) model <- setNames(vector(mode='list', length=length(te_set)), paste0(\"k-\", te_set)) fc_obj <- setNames(vector(mode='list', length=length(te_set)), paste0(\"k-\", te_set))  # ETS model with log transformation ets_log <- function(x, ...){   x[x==0] <- min(x[x!=0])/2   ets(x, lambda = 0, ...) }  for(k in te_set){   model[[paste0(\"k-\", k)]] <- ets_log(data_k[[paste0(\"k-\", k)]])   fc_obj[[paste0(\"k-\", k)]] <- forecast(model[[paste0(\"k-\", k)]], h = m/k) } # Point forecasts base <- lapply(fc_obj, function(x) x$mean) str(base, give.attr = FALSE) #> List of 6 #>  $ k-12: Time-Series [1:1] from 2017 to 2017: 1.31 #>  $ k-6 : Time-Series [1:2] from 2017 to 2018: 0.557 0.557 #>  $ k-4 : Time-Series [1:3] from 2017 to 2018: 0.356 0.356 0.356 #>  $ k-3 : Time-Series [1:4] from 2017 to 2018: 0.243 0.243 0.243 0.243 #>  $ k-2 : Time-Series [1:6] from 2017 to 2018: 0.225 0.225 0.225 0.225 0.225 ... #>  $ k-1 : Time-Series [1:12] from 2017 to 2018: 0.178 0.178 0.178 0.178 0.178 ... # Residuals res <- lapply(fc_obj, residuals, type = \"response\") str(res, give.attr = FALSE) #> List of 6 #>  $ k-12: Time-Series [1:19] from 1998 to 2016: 18.15 -1.18 1.13 31.64 13.37 ... #>  $ k-6 : Time-Series [1:38] from 1998 to 2016: -0.422 18.911 -0.422 -0.422 -0.422 ... #>  $ k-4 : Time-Series [1:57] from 1998 to 2017: -0.221 14.333 4.423 -0.221 -0.221 ... #>  $ k-3 : Time-Series [1:76] from 1998 to 2017: -0.243 -0.228 14.338 4.377 -0.306 ... #>  $ k-2 : Time-Series [1:114] from 1998 to 2017: -0.0904 -0.0904 -0.0904 14.4633 -0.0905 ... #>  $ k-1 : Time-Series [1:228] from 1998 to 2017: -0.0433 -0.0433 -0.0433 -0.0433 -0.0433 ... fc_bts <- base$`k-1` rf_bu <- tebu(fc_bts, agg_order = m) str(rf_bu, give.attr = FALSE) #>  Named num [1:28] 2.137 1.069 1.069 0.712 0.712 ... str(FoReco2matrix(rf_bu), give.attr=FALSE) #> List of 6 #>  $ k-12: num 2.14 #>  $ k-6 : num [1:2] 1.07 1.07 #>  $ k-4 : num [1:3] 0.712 0.712 0.712 #>  $ k-3 : num [1:4] 0.534 0.534 0.534 0.534 #>  $ k-2 : num [1:6] 0.356 0.356 0.356 0.356 0.356 ... #>  $ k-1 : num [1:12] 0.178 0.178 0.178 0.178 0.178 ... y_mat <- matrix(data_k$`k-1`, ncol = m, byrow = TRUE) x12 <- data_k$`k-12` fc_x12 <- base$`k-12`  # Average historical proportions - Gross-Sohl method A p_gsa <- colMeans(apply(y_mat, 2, function(x) x/x12), na.rm = TRUE) rf_td_gsa <- tetd(fc_x12, agg_order = m, weights = p_gsa) str(rf_td_gsa, give.attr = FALSE) #>  Named num [1:28] 1.314 0.497 0.818 0.216 0.791 ...  # Proportions of the historical averages - Gross-Sohl method F p_gsf <- colMeans(y_mat)/mean(x12) rf_td_gsf <- tetd(fc_x12, agg_order = m, weights = p_gsf) str(rf_td_gsf, give.attr = FALSE) #>  Named num [1:28] 1.314 0.501 0.813 0.079 0.99 ... base_vec <- unlist(base, use.names = FALSE) res_vec <- unlist(res, use.names = FALSE) rf_lcc <- telcc(base = base_vec, agg_order = m,                 res = res_vec, comb = \"wlsv\") str(rf_lcc, give.attr = FALSE) #>  Named num [1:28] 1.326 0.663 0.663 0.442 0.442 ... rf_opt <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"sar1\") str(rf_opt, give.attr = FALSE) #>  Named num [1:28] 1.329 0.665 0.665 0.443 0.443 ... rf_opt_shr <- terec(base = base_vec, agg_order = m,                     res = res_vec, comb = \"shr\") recoinfo(rf_opt_shr) #> ✔ Optimal Temporal Forecast Reconciliation #> ℹ FoReco function: `terec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `FALSE` rf_osqp <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"shr\", nn = \"osqp\") tmp <- recoinfo(rf_osqp) #> ✔ Optimal Temporal Forecast Reconciliation #> ℹ FoReco function: `terec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE` tmp$info # OSQP information matrix  #>     obj_val    run_time iter      pri_res status status_polish #> 1 -16.58821 0.000289833   50 5.551115e-17      1             1 rf_sntz <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"shr\", nn = \"sntz\") recoinfo(rf_sntz) #> ✔ Optimal Temporal Forecast Reconciliation #> ℹ FoReco function: `terec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE` rf_imm <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"sar1\", immutable = rbind(c(12,1))) str(rf_imm, give.attr = FALSE) #>  Named num [1:28] 1.314 0.657 0.657 0.438 0.438 ... rf_imm[1] - base_vec[1] #> k-12 h-1  #>        0 te_subset <- c(12, 3, 1) base_vec2 <- unlist(base[paste0(\"k-\", te_subset)], use.names = FALSE) res_vec2 <- unlist(res[paste0(\"k-\", te_subset)], use.names = FALSE) rf_sub <- terec(base = base_vec2, agg_order = te_subset,                 res = res_vec2, comb = \"sar1\") str(rf_sub, give.attr = FALSE) #>  Named num [1:17] 1.48 0.371 0.369 0.369 0.371 ... # Base forecasts' sample: # we simulate from the base models by sampling errors  # while keeping the cross-sectional dimension fixed. B <- 100 base_tejb <- teboot(model, B, m)$sample dim(base_tejb) #> [1] 100  28 reco_tejb <- tesample(base_tejb, agg_order = m, res = res_vec, nn = \"sntz\", comb = \"sar1\") reco_tejb # distribution object #> <distribution[1]> #>       tao-1  #> sample[100]  # Extracts mean: str(as_tevector(mean(reco_tejb), agg_order = m), give.attr = FALSE) #>  Named num [1:28] 5.907 2.028 3.879 0.485 4.244 ... # Gaussian reconciled distribution reco_teg_sar1 <- tegauss(base = base_vec, agg_order = m, comb = \"sar1\", res = res_vec) reco_teg_sar1 # distribution object #> <distribution[1]> #>   tao-1  #> MVN[28]  # Gaussian reconciled distribution with different base covariance matrix # Multi-step residuals hres <- lapply(model, function(fit)   lapply(1:frequency(fit$x), function(h) residuals(fit, type='response', h = h))) hres <- Reduce(\"c\", lapply(hres, arrange_hres)) # Re-arrenge multi-step residuals in a matrix form mres <- as_hstack_telayout(hres, agg_order = m) cov_base <- shrink_estim(mres)  reco_teg <- tegauss(base = base_vec, agg_order = m, comb = \"sar1\",                      res = res_vec, comb_base = cov_base) reco_teg # distribution object #> <distribution[1]> #>   tao-1  #> MVN[28]  # Reconciled sample distribution starting from gaussian base forecasts base_tes <- MASS::mvrnorm(n = B, mu = base_vec, Sigma = shrink_estim(mres)) reco_tes <- tesample(base_tes, agg_order = m, res = res_vec, nn = \"sntz\", comb = \"sar1\") reco_tes # distribution object #> <distribution[1]> #>       tao-1  #> sample[100]"},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"base-forecast","dir":"Articles","previous_headings":"","what":"Base Forecast","title":"Temporal forecast reconciliation","text":"obtained base forecasts, fit ETS model log transformation. obtain twelve-, six-, four-, three-, two-, one-step-ahead base forecasts monthly data aggregation 2, 3, 4, 6, 12 months. extract point forecasts residuals fitted models.","code":"data_k <- aggts(y, te_set) model <- setNames(vector(mode='list', length=length(te_set)), paste0(\"k-\", te_set)) fc_obj <- setNames(vector(mode='list', length=length(te_set)), paste0(\"k-\", te_set))  # ETS model with log transformation ets_log <- function(x, ...){   x[x==0] <- min(x[x!=0])/2   ets(x, lambda = 0, ...) }  for(k in te_set){   model[[paste0(\"k-\", k)]] <- ets_log(data_k[[paste0(\"k-\", k)]])   fc_obj[[paste0(\"k-\", k)]] <- forecast(model[[paste0(\"k-\", k)]], h = m/k) } # Point forecasts base <- lapply(fc_obj, function(x) x$mean) str(base, give.attr = FALSE) #> List of 6 #>  $ k-12: Time-Series [1:1] from 2017 to 2017: 1.31 #>  $ k-6 : Time-Series [1:2] from 2017 to 2018: 0.557 0.557 #>  $ k-4 : Time-Series [1:3] from 2017 to 2018: 0.356 0.356 0.356 #>  $ k-3 : Time-Series [1:4] from 2017 to 2018: 0.243 0.243 0.243 0.243 #>  $ k-2 : Time-Series [1:6] from 2017 to 2018: 0.225 0.225 0.225 0.225 0.225 ... #>  $ k-1 : Time-Series [1:12] from 2017 to 2018: 0.178 0.178 0.178 0.178 0.178 ... # Residuals res <- lapply(fc_obj, residuals, type = \"response\") str(res, give.attr = FALSE) #> List of 6 #>  $ k-12: Time-Series [1:19] from 1998 to 2016: 18.15 -1.18 1.13 31.64 13.37 ... #>  $ k-6 : Time-Series [1:38] from 1998 to 2016: -0.422 18.911 -0.422 -0.422 -0.422 ... #>  $ k-4 : Time-Series [1:57] from 1998 to 2017: -0.221 14.333 4.423 -0.221 -0.221 ... #>  $ k-3 : Time-Series [1:76] from 1998 to 2017: -0.243 -0.228 14.338 4.377 -0.306 ... #>  $ k-2 : Time-Series [1:114] from 1998 to 2017: -0.0904 -0.0904 -0.0904 14.4633 -0.0905 ... #>  $ k-1 : Time-Series [1:228] from 1998 to 2017: -0.0433 -0.0433 -0.0433 -0.0433 -0.0433 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"point-reconciliation","dir":"Articles","previous_headings":"","what":"Point Reconciliation","title":"Temporal forecast reconciliation","text":"Bottom-reconciliation (Dunn et al., 1976) aggregates high-frequency forecasts monthly level higher temporal levels (Girolimetto et al., 2024). obtain list forecasts different orders aggregation, can use FoReco2matrix function. top-reconciliation hierarchical time series, forecast annual series (\\(k = 12\\)) distributed proportionally ensure top-level value stays bottom-level forecasts non-negative (Gross & Sohl, 1990). perform temporal reconciliation FoReco using base forecasts temporal aggregation order, necessary arrange base forecasts (residuals) vector form. level conditional coherent reconciliation (LCC) generalization original proposal Hollyman et al. (2021) Di Fonzo & Girolimetto (2024) include temporal framework. Finally can obtained optimal (least squares sense) combination temporal reconciled forecast (Athanasopoulos et al., 2017). following table shows options optimal combination temporal reconciliation function terec().","code":"fc_bts <- base$`k-1` rf_bu <- tebu(fc_bts, agg_order = m) str(rf_bu, give.attr = FALSE) #>  Named num [1:28] 2.137 1.069 1.069 0.712 0.712 ... str(FoReco2matrix(rf_bu), give.attr=FALSE) #> List of 6 #>  $ k-12: num 2.14 #>  $ k-6 : num [1:2] 1.07 1.07 #>  $ k-4 : num [1:3] 0.712 0.712 0.712 #>  $ k-3 : num [1:4] 0.534 0.534 0.534 0.534 #>  $ k-2 : num [1:6] 0.356 0.356 0.356 0.356 0.356 ... #>  $ k-1 : num [1:12] 0.178 0.178 0.178 0.178 0.178 ... y_mat <- matrix(data_k$`k-1`, ncol = m, byrow = TRUE) x12 <- data_k$`k-12` fc_x12 <- base$`k-12`  # Average historical proportions - Gross-Sohl method A p_gsa <- colMeans(apply(y_mat, 2, function(x) x/x12), na.rm = TRUE) rf_td_gsa <- tetd(fc_x12, agg_order = m, weights = p_gsa) str(rf_td_gsa, give.attr = FALSE) #>  Named num [1:28] 1.314 0.497 0.818 0.216 0.791 ...  # Proportions of the historical averages - Gross-Sohl method F p_gsf <- colMeans(y_mat)/mean(x12) rf_td_gsf <- tetd(fc_x12, agg_order = m, weights = p_gsf) str(rf_td_gsf, give.attr = FALSE) #>  Named num [1:28] 1.314 0.501 0.813 0.079 0.99 ... base_vec <- unlist(base, use.names = FALSE) res_vec <- unlist(res, use.names = FALSE) rf_lcc <- telcc(base = base_vec, agg_order = m,                 res = res_vec, comb = \"wlsv\") str(rf_lcc, give.attr = FALSE) #>  Named num [1:28] 1.326 0.663 0.663 0.442 0.442 ... rf_opt <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"sar1\") str(rf_opt, give.attr = FALSE) #>  Named num [1:28] 1.329 0.665 0.665 0.443 0.443 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"practical-challenges","dir":"Articles","previous_headings":"","what":"Practical challenges","title":"Temporal forecast reconciliation","text":"always true reconciled forecasts remain non-negative even base forecasts non-negative. example, consider case shrinkage covariance matrix (\"shr\"). address issue, can use two approaches: State---art numerical optimization procedure, osqp (Stellato et al., 2020). Simple heuristic strategy: set-negative--zero, sntz (Di Fonzo & Girolimetto, 2023). Sometimes may wish incorporate priori knowledge reconciliation process (Zhang et al., 2023) order improve accuracy reconciled forecasts. example, suppose want fix forecasts annual level base forecasts values. approaches far involved considering factors \\(m\\) potential aggregation orders. Nevertheless, worth noting also focus given subset factors. example, interested monthly, quarterly annual forecasts.","code":"rf_opt_shr <- terec(base = base_vec, agg_order = m,                     res = res_vec, comb = \"shr\") recoinfo(rf_opt_shr) #> ✔ Optimal Temporal Forecast Reconciliation #> ℹ FoReco function: `terec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `FALSE` rf_osqp <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"shr\", nn = \"osqp\") tmp <- recoinfo(rf_osqp) #> ✔ Optimal Temporal Forecast Reconciliation #> ℹ FoReco function: `terec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE` tmp$info # OSQP information matrix  #>     obj_val    run_time iter      pri_res status status_polish #> 1 -16.58821 0.000289833   50 5.551115e-17      1             1 rf_sntz <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"shr\", nn = \"sntz\") recoinfo(rf_sntz) #> ✔ Optimal Temporal Forecast Reconciliation #> ℹ FoReco function: `terec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE` rf_imm <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"sar1\", immutable = rbind(c(12,1))) str(rf_imm, give.attr = FALSE) #>  Named num [1:28] 1.314 0.657 0.657 0.438 0.438 ... rf_imm[1] - base_vec[1] #> k-12 h-1  #>        0 te_subset <- c(12, 3, 1) base_vec2 <- unlist(base[paste0(\"k-\", te_subset)], use.names = FALSE) res_vec2 <- unlist(res[paste0(\"k-\", te_subset)], use.names = FALSE) rf_sub <- terec(base = base_vec2, agg_order = te_subset,                 res = res_vec2, comb = \"sar1\") str(rf_sub, give.attr = FALSE) #>  Named num [1:17] 1.48 0.371 0.369 0.369 0.371 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"non-negativity-issues","dir":"Articles","previous_headings":"Capital Country monthly time series","what":"Non negativity issues","title":"Temporal forecast reconciliation","text":"always true reconciled forecasts remain non-negative even base forecasts non-negative. example, consider case shrinkage covariance matrix (\"shr\"). address issue, can use two approaches: State---art numerical optimization procedure, osqp (Stellato et al., 2020). Simple heuristic strategy: set-negative--zero, sntz (Di Fonzo & Girolimetto, 2023).","code":"rf_opt_shr <- terec(base = base_vec, agg_order = m,                     res = res_vec, comb = \"shr\") recoinfo(rf_opt_shr) #> ✔ Optimal Temporal Forecast Reconciliation #> ℹ FoReco function: `terec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `FALSE` rf_osqp <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"shr\", nn = \"osqp\") tmp <- recoinfo(rf_osqp) #> ✔ Optimal Temporal Forecast Reconciliation #> ℹ FoReco function: `terec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE` tmp$info # OSQP information matrix  #>     obj_val    run_time iter      pri_res status status_polish #> 1 -16.58821 0.000289833   50 5.551115e-17      1             1 rf_sntz <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"shr\", nn = \"sntz\") recoinfo(rf_sntz) #> ✔ Optimal Temporal Forecast Reconciliation #> ℹ FoReco function: `terec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE`"},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"a-priori-constrained-immutable-forecasts","dir":"Articles","previous_headings":"Capital Country monthly time series","what":"A priori constrained (immutable) forecasts","title":"Temporal forecast reconciliation","text":"Sometimes may wish incorporate priori knowledge reconciliation process (Zhang et al., 2023) order improve accuracy reconciled forecasts. example, suppose want fix forecasts annual level base forecasts values.","code":"rf_imm <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"sar1\", immutable = rbind(c(12,1))) str(rf_imm, give.attr = FALSE) #>  Named num [1:28] 1.314 0.657 0.657 0.438 0.438 ... rf_imm[1] - base_vec[1] #> k-12 h-1  #>        0"},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"exploring-a-subset-of-temporal-aggregation-orders","dir":"Articles","previous_headings":"Capital Country monthly time series","what":"Exploring a subset of temporal aggregation orders","title":"Temporal forecast reconciliation","text":"approaches far involved considering factors \\(m\\) potential aggregation orders. Nevertheless, worth noting also focus given subset factors. example, interested monthly, quarterly annual forecasts.","code":"te_subset <- c(12, 3, 1) base_vec2 <- unlist(base[paste0(\"k-\", te_subset)], use.names = FALSE) res_vec2 <- unlist(res[paste0(\"k-\", te_subset)], use.names = FALSE) rf_sub <- terec(base = base_vec2, agg_order = te_subset,                 res = res_vec2, comb = \"sar1\") str(rf_sub, give.attr = FALSE) #>  Named num [1:17] 1.48 0.371 0.369 0.369 0.371 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"probabilistic-reconciliation","dir":"Articles","previous_headings":"","what":"Probabilistic Reconciliation","title":"Temporal forecast reconciliation","text":"Following Panagiotelis et al. (2023) Girolimetto et al. (2024), reconciliation probabilistic forecasts two-step process: first, sample incoherent distributio, reconcile sample. can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . parametric method assumes normal distribution (Gaussian) generate incoherent sample set forecasts.","code":"# Base forecasts' sample: # we simulate from the base models by sampling errors  # while keeping the cross-sectional dimension fixed. B <- 100 base_tejb <- teboot(model, B, m)$sample dim(base_tejb) #> [1] 100  28 reco_tejb <- tesample(base_tejb, agg_order = m, res = res_vec, nn = \"sntz\", comb = \"sar1\") reco_tejb # distribution object #> <distribution[1]> #>       tao-1  #> sample[100]  # Extracts mean: str(as_tevector(mean(reco_tejb), agg_order = m), give.attr = FALSE) #>  Named num [1:28] 5.907 2.028 3.879 0.485 4.244 ... # Gaussian reconciled distribution reco_teg_sar1 <- tegauss(base = base_vec, agg_order = m, comb = \"sar1\", res = res_vec) reco_teg_sar1 # distribution object #> <distribution[1]> #>   tao-1  #> MVN[28]  # Gaussian reconciled distribution with different base covariance matrix # Multi-step residuals hres <- lapply(model, function(fit)   lapply(1:frequency(fit$x), function(h) residuals(fit, type='response', h = h))) hres <- Reduce(\"c\", lapply(hres, arrange_hres)) # Re-arrenge multi-step residuals in a matrix form mres <- as_hstack_telayout(hres, agg_order = m) cov_base <- shrink_estim(mres)  reco_teg <- tegauss(base = base_vec, agg_order = m, comb = \"sar1\",                      res = res_vec, comb_base = cov_base) reco_teg # distribution object #> <distribution[1]> #>   tao-1  #> MVN[28]  # Reconciled sample distribution starting from gaussian base forecasts base_tes <- MASS::mvrnorm(n = B, mu = base_vec, Sigma = shrink_estim(mres)) reco_tes <- tesample(base_tes, agg_order = m, res = res_vec, nn = \"sntz\", comb = \"sar1\") reco_tes # distribution object #> <distribution[1]> #>       tao-1  #> sample[100]"},{"path":[]},{"path":"https://danigiro.github.io/FoReco/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniele Girolimetto. Author, maintainer, funder. Tommaso Di Fonzo. Author, funder.","code":""},{"path":"https://danigiro.github.io/FoReco/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Girolimetto D, Di Fonzo T (2025). FoReco: Forecast Reconciliation. R package. doi:10.32614/CRAN.package.FoReco, https://cran.r-project.org/package=FoReco. Di Fonzo T, Girolimetto D (2023). “Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives.” International Journal Forecasting, 39(1), 134. doi:10.1016/j.ijforecast.2021.08.004. Girolimetto D, Athanasopoulos G, Di Fonzo T, Hyndman R (2024). “Cross-temporal probabilistic forecast reconciliation: Methodological practical issues.” International Journal Forecasting, 40(3), 2285. doi:10.1016/j.ijforecast.2023.10.003.","code":"@Manual{,   title = {FoReco: Forecast Reconciliation},   author = {Daniele Girolimetto and Tommaso {Di Fonzo}},   organization = {R package},   year = {2025},   doi = {10.32614/CRAN.package.FoReco},   url = {https://cran.r-project.org/package=FoReco}, } @Article{,   title = {Cross-temporal forecast reconciliation: Optimal combination method and heuristic alternatives},   author = {Tommaso {Di Fonzo} and Daniele Girolimetto},   journal = {International Journal of Forecasting},   volume = {39},   year = {2023},   number = {1},   pages = {134},   doi = {10.1016/j.ijforecast.2021.08.004}, } @Article{,   title = {Cross-temporal probabilistic forecast reconciliation: Methodological and practical issues},   author = {Daniele Girolimetto and George Athanasopoulos and Tommaso {Di Fonzo} and Rob J Hyndman},   journal = {International Journal of Forecasting},   volume = {40},   year = {2024},   number = {3},   pages = {2285},   doi = {10.1016/j.ijforecast.2023.10.003}, }"},{"path":"https://danigiro.github.io/FoReco/index.html","id":"foreco-","dir":"","previous_headings":"","what":"Forecast Reconciliation","title":"Forecast Reconciliation","text":"Forecast Reconciliation post-forecasting process aimed improve accuracy align forecasts system linearly constrained (e.g. hierarchical/grouped) time series. FoReco package provides comprehensive set classical (bottom-, top-middle-), modern (optimal heuristic combination) forecast reconciliation procedures different frameworks including cross-sectional, temporal, cross-temporal settings. core functions reconciliation categorized framework follows: Additionally, FoReco provides various functions different aspects forecast reconciliation, including aggregating time series, balancing hierarchies, computing projection covariance matrices, .","code":""},{"path":"https://danigiro.github.io/FoReco/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Forecast Reconciliation","text":"can install stable version R CRAN can also install development version Github","code":"install.packages(\"FoReco\") # install.packages(\"devtools\") devtools::install_github(\"danigiro/FoReco\")"},{"path":"https://danigiro.github.io/FoReco/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"Forecast Reconciliation","text":"get started using FoReco package, refer documentation detailed information apply different forecast reconciliation procedures data. vndata itagdp dataset Cross-sectional forecast reconciliation Temporal forecast reconciliation Cross-temporal forecast reconciliation Replicate hts package Replicate thief package","code":""},{"path":"https://danigiro.github.io/FoReco/index.html","id":"issues-and-contributions","dir":"","previous_headings":"","what":"Issues and Contributions","title":"Forecast Reconciliation","text":"encounter bugs suggestions improvements, please feel free report GitHub Issues page. Contributions also welcome!","code":""},{"path":"https://danigiro.github.io/FoReco/reference/FoReco-package.html","id":null,"dir":"Reference","previous_headings":"","what":"FoReco: Forecast Reconciliation — FoReco-package","title":"FoReco: Forecast Reconciliation — FoReco-package","text":"Classical (bottom-top-), optimal combination heuristic point (Di Fonzo Girolimetto, 2023 doi:10.1016/j.ijforecast.2021.08.004 ) probabilistic (Girolimetto et al. 2024 doi:10.1016/j.ijforecast.2023.10.003 ) forecast reconciliation procedures linearly constrained time series (e.g., hierarchical grouped time series) cross-sectional, temporal, cross-temporal frameworks.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/FoReco-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"FoReco: Forecast Reconciliation — FoReco-package","text":"Maintainer: Daniele Girolimetto daniele.girolimetto@unipd.(ORCID) [funder] Authors: Tommaso Di Fonzo (ORCID) [funder]","code":""},{"path":"https://danigiro.github.io/FoReco/reference/FoReco2matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconciled forecasts to matrix/vector — FoReco2matrix","title":"Reconciled forecasts to matrix/vector — FoReco2matrix","text":"function splits temporal vectors cross-temporal matrices list according temporal aggregation order","code":""},{"path":"https://danigiro.github.io/FoReco/reference/FoReco2matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconciled forecasts to matrix/vector — FoReco2matrix","text":"","code":"FoReco2matrix(x, agg_order, keep_names = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/FoReco2matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconciled forecasts to matrix/vector — FoReco2matrix","text":"x output reconciliation function implemented FoReco. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). keep_names FALSE (default), rownames names output matrices removed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/FoReco2matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconciled forecasts to matrix/vector — FoReco2matrix","text":"list matrices vectors distinct temporal aggregation order.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/FoReco2matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reconciled forecasts to matrix/vector — FoReco2matrix","text":"","code":"set.seed(123) # (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4 base <- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))))  reco <- ctrec(base = base, agg_mat = t(c(1,1)), agg_order = 4, comb = \"ols\") matrix_list <- FoReco2matrix(reco)"},{"path":"https://danigiro.github.io/FoReco/reference/aggts.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-overlapping temporal aggregation of a time series — aggts","title":"Non-overlapping temporal aggregation of a time series — aggts","text":"Non-overlapping temporal aggregation time series according specific aggregation order.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/aggts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-overlapping temporal aggregation of a time series — aggts","text":"","code":"aggts(y, agg_order, tew = \"sum\", align = \"end\", rm_na = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/aggts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-overlapping temporal aggregation of a time series — aggts","text":"y Univariate multivariate time series: vector/matrix ts object. agg_order numeric vector aggregation orders consider. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). align string vector specifying alignment y. Options include: \"end\" (end series, default), \"start\" (start series), integer (vector integers) indicating starting period temporally aggregated series. rm_na TRUE missing values removed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/aggts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-overlapping temporal aggregation of a time series — aggts","text":"list vectors ts objects.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/aggts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-overlapping temporal aggregation of a time series — aggts","text":"","code":"# Monthly time series (input vector) y <- ts(rnorm(24), start = 2020, frequency = 12) # Quarterly time series x1 <- aggts(y, 3) # Monthly, quarterly and annual time series x2 <- aggts(y, c(1, 3, 12)) # All temporally aggregated time series x3 <- aggts(y)  # Ragged data y2 <- ts(rnorm(11), start = c(2020, 3), frequency = 4) # Annual time series: start in 2021 x4 <- aggts(y2, 4, align = 3) # Semi-annual (start in 2nd semester of 2020) and annual (start in 2021) time series x5 <- aggts(y2, c(2, 4), align = c(1, 3))"},{"path":"https://danigiro.github.io/FoReco/reference/balance_hierarchy.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form — balance_hierarchy","title":"Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form — balance_hierarchy","text":"hierarchy \\(L\\) upper levels said balanced variable level \\(l\\) least one child level \\(l+1\\). hold, hierarchy unbalanced. function transforms aggregation matrix unbalanced hierarchy aggregation matrix balanced one. function used reconcile forecasts cslcc, operates exclusively balanced hierarchies.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/balance_hierarchy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form — balance_hierarchy","text":"","code":"balance_hierarchy(agg_mat, nodes = \"auto\", sparse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/balance_hierarchy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form — balance_hierarchy","text":"agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. nodes (\\(L \\times 1\\)) numeric vector indicating number variables upper \\(L\\) levels hierarchy. default value string \"auto\" calculates number variables level. sparse Option return sparse matrices (default TRUE).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/balance_hierarchy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form — balance_hierarchy","text":"list containing four elements: bam balanced aggregation matrix. agg_mat input matrix. nodes (\\(L \\times 1\\)) numeric vector indicating number variables \\(L\\) upper levels balanced hierarchy. id identification number variable balanced hierarchy. may contains duplicated values.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/balance_hierarchy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form — balance_hierarchy","text":"","code":"#    Unbalanced     ->      Balanced #        T                     T #    |-------|             |-------| #    A       |             A       B #  |---|     |           |---|     | # AA   AB    B          AA   AB    BA A <- matrix(c(1, 1, 1,               1, 1, 0), 2, byrow = TRUE) obj <- balance_hierarchy(agg_mat = A, nodes = c(1, 1)) obj$bam #> 3 x 3 sparse Matrix of class \"dgCMatrix\" #>            #> [1,] 1 1 1 #> [2,] 1 1 . #> [3,] . . 1"},{"path":"https://danigiro.github.io/FoReco/reference/commat.html","id":null,"dir":"Reference","previous_headings":"","what":"Commutation matrix — commat","title":"Commutation matrix — commat","text":"function returns (\\(r c \\times r c\\)) commutation matrix \\(\\mathbf{P}\\) \\(\\mathbf{P} \\mbox{vec}(\\mathbf{Y}) = \\mbox{vec}(\\mathbf{Y}'),\\) \\(\\mathbf{Y}\\) (\\(r \\times c\\)) matrix (Magnus Neudecker, 2019).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/commat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Commutation matrix — commat","text":"","code":"# Commutation matrix commat(r, c)  # Vector of indexes for the rows of commutation matrix commat_index(r, c)"},{"path":"https://danigiro.github.io/FoReco/reference/commat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Commutation matrix — commat","text":"r Number rows \\(\\mathbf{Y}\\). c Number columns \\(\\mathbf{Y}\\).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/commat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Commutation matrix — commat","text":"sparse (\\(r c \\times r c\\)) matrix \\(\\mathbf{P}\\) (commat), vector indexes rows commutation matrix \\(\\mathbf{P}\\) (commat_index)","code":""},{"path":"https://danigiro.github.io/FoReco/reference/commat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Commutation matrix — commat","text":"Magnus, J.R. Neudecker, H. (2019), Matrix Differential Calculus Applications Statistics Econometrics, third edition, New York, Wiley, pp. 54-55.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/commat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Commutation matrix — commat","text":"","code":"Y <- matrix(rnorm(30), 5, 6) P <- commat(5, 6) P %*% as.vector(Y) == as.vector(t(Y)) # check #> 30 x 1 Matrix of class \"lgeMatrix\" #>       [,1] #>  [1,] TRUE #>  [2,] TRUE #>  [3,] TRUE #>  [4,] TRUE #>  [5,] TRUE #>  [6,] TRUE #>  [7,] TRUE #>  [8,] TRUE #>  [9,] TRUE #> [10,] TRUE #> [11,] TRUE #> [12,] TRUE #> [13,] TRUE #> [14,] TRUE #> [15,] TRUE #> [16,] TRUE #> [17,] TRUE #> [18,] TRUE #> [19,] TRUE #> [20,] TRUE #> [21,] TRUE #> [22,] TRUE #> [23,] TRUE #> [24,] TRUE #> [25,] TRUE #> [26,] TRUE #> [27,] TRUE #> [28,] TRUE #> [29,] TRUE #> [30,] TRUE"},{"path":"https://danigiro.github.io/FoReco/reference/csboot.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional joint block bootstrap — csboot","title":"Cross-sectional joint block bootstrap — csboot","text":"Joint block bootstrap generating probabilistic base forecasts take account correlation different time series (Panagiotelis et al. 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csboot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional joint block bootstrap — csboot","text":"","code":"csboot(model_list, boot_size, block_size, seed = NULL)"},{"path":"https://danigiro.github.io/FoReco/reference/csboot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional joint block bootstrap — csboot","text":"model_list list \\(n\\) base forecasts models. simulate() function model available implemented according package forecast, following mandatory parameters: object, innov, future, nsim. boot_size number bootstrap replicates. block_size Block size bootstrap, typically equivalent forecast horizon. seed integer seed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csboot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional joint block bootstrap — csboot","text":"list two elements: seed used sample errors 3-d array (\\(\\text{block\\_size} \\times n \\times \\text{boot\\_size}\\)).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csboot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-sectional joint block bootstrap — csboot","text":"Panagiotelis, ., Gamakumara, P., Athanasopoulos, G. Hyndman, R.J. (2023), Probabilistic forecast reconciliation: Properties, evaluation score optimisation, European Journal Operational Research 306(2), 693–706. doi:10.1016/j.ejor.2022.07.040","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/csbu.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional bottom-up reconciliation — csbu","title":"Cross-sectional bottom-up reconciliation — csbu","text":"function computes cross-sectional bottom-reconciled forecasts (Dunn et al., 1976) series appropriate summation bottom base forecasts \\(\\widehat{\\mathbf{b}}\\): $$\\widetilde{\\mathbf{y}} = \\mathbf{S}_{cs}\\widehat{\\mathbf{b}},$$ \\(\\mathbf{S}_{cs}\\) cross-sectional structural matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csbu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional bottom-up reconciliation — csbu","text":"","code":"csbu(base, agg_mat, sntz = FALSE, round = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/csbu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional bottom-up reconciliation — csbu","text":"base (\\(h \\times n_b\\)) numeric matrix multivariate time series (mts class) containing bottom base forecasts; \\(h\\) forecast horizon, \\(n_b\\) total number bottom variables. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. sntz Logical. TRUE, negative base forecasts set zero (Di Fonzo Girolimetto, 2023) applying bottom-. Default FALSE. round Logical. TRUE, base forecasts rounded applying bottom-reconciliation. Default FALSE.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csbu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional bottom-up reconciliation — csbu","text":"(\\(h \\times n\\)) numeric matrix cross-sectional reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csbu.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-sectional bottom-up reconciliation — csbu","text":"Dunn, D. M., Williams, W. H. Dechaine, T. L. (1976), Aggregate versus subaggregate models local area forecasting, Journal American Statistical Association 71(353), 68–71. doi:10.1080/01621459.1976.10481478 Di Fonzo, T. Girolimetto, D. (2023), Spatio-temporal reconciliation solar forecasts, Solar Energy, 251, 13–29. doi:10.1016/j.solener.2023.01.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/csbu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional bottom-up reconciliation — csbu","text":"","code":"set.seed(123) # (3 x 2) bottom base forecasts matrix (simulated), Z = X + Y bts <- matrix(rnorm(6, mean = c(10, 10)), 3, byrow = TRUE)  # Aggregation matrix for Z = X + Y A <- t(c(1,1)) reco <- csbu(base = bts, agg_mat = A)  # Non negative reconciliation bts[2,2] <- -bts[2,2] # Making negative one of the base forecasts for Y nnreco <- csbu(base = bts, agg_mat = A, sntz = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/cscov.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional covariance matrix approximation — cscov","title":"Cross-sectional covariance matrix approximation — cscov","text":"function provides approximation cross-sectional base forecasts errors covariance matrix using different reconciliation methods (see Wickramasuriya et al., 2019 Di Fonzo Girolimetto, 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cscov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional covariance matrix approximation — cscov","text":"","code":"cscov(comb = \"ols\", n = NULL, agg_mat = NULL, res, mse = TRUE,       shrink_fun = shrink_estim, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/cscov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional covariance matrix approximation — cscov","text":"comb string specifying covariance approximation method. ordinary least squares reconciliation: \"ols\" (default) - identity error covariance matrix. weighted least squares reconciliation: \"str\" - structural variances. \"wls\" - series variances (uses res). generalized least squares (uses res) reconciliation: \"shr\" - shrunk covariance (Wickramasuriya et al., 2019). \"oasd\" - oracle shrunk covariance (Ando Xiao, 2023). \"sam\" - sample covariance. Others (reconciliation): \"bu\" - bottom-covariance. n Number variables (\\(n = n_a + n_b\\)). agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. res (\\(N \\times n\\)) optional numeric matrix containing -sample residuals. matrix used compute covariance matrices. mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default). ... used.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cscov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional covariance matrix approximation — cscov","text":"(\\(n \\times n\\)) symmetric positive (semi-)definite matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cscov.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-sectional covariance matrix approximation — cscov","text":"Ando, S., Xiao, M. (2023), High-dimensional covariance matrix estimation: shrinkage toward diagonal target. IMF Working Papers, 2023(257), A001. Di Fonzo, T. Girolimetto, D. (2023), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004 Wickramasuriya, S.L., Athanasopoulos, G. Hyndman, R.J. (2019), Optimal forecast reconciliation hierarchical grouped time series trace minimization, Journal American Statistical Association, 114, 526, 804-819. doi:10.1080/01621459.2018.1448825","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cscov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional covariance matrix approximation — cscov","text":"","code":"# Aggregation matrix for Z = X + Y A <- t(c(1,1)) # (10 x 3) in-sample residuals matrix (simulated) res <- t(matrix(rnorm(n = 30), nrow = 3))  cov1 <- cscov(\"ols\", n = 3)          # OLS methods cov2 <- cscov(\"str\", agg_mat = A)    # STR methods cov3 <- cscov(\"wls\", res = res)      # WLS methods cov4 <- cscov(\"shr\", res = res)      # SHR methods cov5 <- cscov(\"sam\", res = res)      # SAM methods  # Custom covariance matrix cscov.ols2 <- function(comb, x) diag(x) cscov(comb = \"ols2\", x = 3) # == cscov(\"ols\", n = 3) #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1"},{"path":"https://danigiro.github.io/FoReco/reference/csgauss.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional Gaussian probabilistic reconciliation — csgauss","title":"Cross-sectional Gaussian probabilistic reconciliation — csgauss","text":"Cross-sectional Gaussian probabilistic reconciliation","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csgauss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional Gaussian probabilistic reconciliation — csgauss","text":"","code":"csgauss(   base,   agg_mat,   cons_mat,   comb = \"ols\",   comb_base = comb,   res = NULL,   approach = \"proj\",   reduce_form = FALSE,   ... )"},{"path":"https://danigiro.github.io/FoReco/reference/csgauss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional Gaussian probabilistic reconciliation — csgauss","text":"base (\\(h \\times n\\)) numeric matrix multivariate time series (mts class) containing base forecasts reconciled; \\(h\\) forecast horizon, \\(n\\) total number time series (\\(n = n_a + n_b\\)). agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints: row represents constraint equation, column represents variable. matrix can full rank, meaning rows linearly independent, strict requirement, function allows redundancy constraints. comb string specifying reconciliation method. complete list, see cscov. comb_base string specifying reconciliation method. complete list, see cscov. res (\\(N \\times n\\)) optional numeric matrix containing -sample residuals. matrix used compute covariance matrices. approach string specifying approach used compute reconciled mean covariance matrix. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). reduce_form logical parameter indicating whether function return full distribution (FALSE, default) distribution corresponding bottom-level time series (TRUE). ... Arguments passed cscov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csgauss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional Gaussian probabilistic reconciliation — csgauss","text":"distributional::dist_multivariate_normal object.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csgauss.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-sectional Gaussian probabilistic reconciliation — csgauss","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Panagiotelis, ., Gamakumara, P., Athanasopoulos, G. Hyndman, R.J. (2023), Probabilistic forecast reconciliation: Properties, evaluation score optimisation, European Journal Operational Research 306(2), 693–706. doi:10.1016/j.ejor.2022.07.040","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/csgauss.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional Gaussian probabilistic reconciliation — csgauss","text":"","code":"set.seed(123) # (2 x 3) base forecasts matrix (simulated), Z = X + Y base <- matrix(rnorm(6, mean = c(20, 10, 10)), 2, byrow = TRUE) # (10 x 3) in-sample residuals matrix (simulated) res <- t(matrix(rnorm(n = 30), nrow = 3))  # Aggregation matrix for Z = X + Y A <- t(c(1,1)) reco_dist <- csgauss(base = base, agg_mat = A, comb = \"shr\", res = res)"},{"path":"https://danigiro.github.io/FoReco/reference/cslcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","title":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","text":"function implements cross-sectional forecast reconciliation procedure extends original proposal Hollyman et al. (2021). Level conditional coherent reconciled forecasts conditional (.e., constrained ) base forecasts specific upper level hierarchy (exogenous constraints). also allows handling linear constraints linking variables endogenously (Di Fonzo Girolimetto, 2022). function can calculate Combined Conditional Coherent (CCC) forecasts simple averages Level-Conditional Coherent (LCC) bottom-reconciled forecasts, either endogenous exogenous constraints.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cslcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","text":"","code":"cslcc(base, agg_mat, nodes = \"auto\", comb = \"ols\", res = NULL, CCC = TRUE,       const = \"exogenous\", bts = NULL, approach = \"proj\", nn = NULL,       settings = NULL, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/cslcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","text":"base (\\(h \\times n\\)) numeric matrix multivariate time series (mts class) containing base forecasts reconciled; \\(h\\) forecast horizon, \\(n\\) total number time series (\\(n = n_a + n_b\\)). agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. nodes (\\(L \\times 1\\)) numeric vector indicating number variables upper \\(L\\) levels hierarchy. default value string \"auto\" calculates number variables level. comb string specifying reconciliation method. complete list, see cscov. res (\\(N \\times n\\)) optional numeric matrix containing -sample residuals. matrix used compute covariance matrices. CCC logical value indicating whether Combined Conditional Coherent reconciled forecasts reconciliation include bottom-forecasts (TRUE, default), . const string specifying reconciliation constraints: \"exogenous\" (default): Fixes top level sub-hierarchy. \"endogenous\": Coherently revises top bottom levels. bts (\\(h \\times n_b\\)) numeric matrix multivariate time series (mts class) containing bottom base forecasts defined user (e.g., seasonal averages, Hollyman et al., 2021). parameter can omitted base forecasts used (see Di Fonzo Girolimetto, 2024). approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. nn string specifying algorithm compute non-negative forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"bpv\": block principal pivoting algorithm. \"sntz\": heuristic \"set-negative--zero\" (Di Fonzo Girolimetto, 2023). settings list control parameters. nn = \"osqp\" object class osqpSettings specifying settings osqp solver. details, refer osqp documentation (Stellato et al., 2020). nn = \"bpv\" includes: ptype permutation method (\"random\" \"fixed\", default), par number full exchange rules may attempted (10, default), tol tolerance convergence criteria (sqrt(.Machine$double.eps), default), gtol gradient tolerance convergence criteria (sqrt(.Machine$double.eps), default), itmax maximum number algorithm iterations (100, default) ... Arguments passed cscov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cslcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","text":"(\\(h \\times n\\)) numeric matrix cross-sectional reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cslcc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Di Fonzo, T. Girolimetto, D. (2024), Forecast combination-based forecast reconciliation: Insights extensions, International Journal Forecasting, 40(2), 490–514. doi:10.1016/j.ijforecast.2022.07.001 Di Fonzo, T. Girolimetto, D. (2023b) Spatio-temporal reconciliation solar forecasts. Solar Energy 251, 13–29. doi:10.1016/j.solener.2023.01.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Hollyman, R., Petropoulos, F. Tipping, M.E. (2021), Understanding forecast reconciliation. European Journal Operational Research, 294, 149–160. doi:10.1016/j.ejor.2021.01.017 Stellato, B., Banjac, G., Goulart, P., Bemporad, . Boyd, S. (2020), OSQP: Operator Splitting solver Quadratic Programs, Mathematical Programming Computation, 12, 4, 637-672. doi:10.1007/s12532-020-00179-2","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cslcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY A <- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE) # (2 x 7) base forecasts matrix (simulated) base <- matrix(rnorm(7*2, mean = c(40, 20, 20, 10, 10, 10, 10)), 2, byrow = TRUE) # (10 x 7) in-sample residuals matrix (simulated) res <- matrix(rnorm(n = 7*10), ncol = 7) # (2 x 7) Naive bottom base forecasts matrix: all forecasts are set equal to 10 naive <- matrix(10, 2, 4)  ## EXOGENOUS CONSTRAINTS (Hollyman et al., 2021) # Level Conditional Coherent (LCC) reconciled forecasts exo_LC <- cslcc(base = base, agg_mat = A, comb = \"wls\", bts = naive,                 res = res, nodes = \"auto\", CCC = FALSE)  # Combined Conditional Coherent (CCC) reconciled forecasts exo_CCC <- cslcc(base = base, agg_mat = A, comb = \"wls\", bts = naive,                  res = res, nodes = \"auto\", CCC = TRUE)  # Results detailed by level: # L-1: Level 1 immutable reconciled forecasts for the whole hierarchy # L-2: Middle-Out reconciled forecasts # L-3: Bottom-Up reconciled forecasts info_exo <- recoinfo(exo_CCC, verbose = FALSE) info_exo$lcc #> $`L-1` #>          s-1      s-2      s-3      s-4      s-5      s-6      s-7 #> h-1 39.43952 19.76757 19.67196 9.893588 9.873979 9.744387 9.927570 #> h-2 38.73494 19.47537 19.25957 9.759815 9.715556 9.423051 9.836517 #> attr(,\"FoReco\") #> <environment: 0x147b8c7e8> #>  #> $`L-2` #>          s-1      s-2      s-3      s-4      s-5       s-6       s-7 #> h-1 41.32853 19.76982 21.55871 9.894620 9.875202 11.214555 10.344153 #> h-2 38.86749 19.31315 19.55434 9.685546 9.627601  9.652737  9.901601 #> attr(,\"FoReco\") #> <environment: 0x147e6b1d0> #>  #> $`L-3` #>          s-1     s-2      s-3      s-4      s-5      s-6      s-7 #> h-1 42.37578 20.1998 22.17598 10.07051 10.12929 11.71506 10.46092 #> h-2 42.09535 21.5839 20.51145 11.22408 10.35981 10.40077 10.11068 #> attr(,\"FoReco\") #> <environment: 0x147f0a158> #>   ## ENDOGENOUS CONSTRAINTS (Di Fonzo and Girolimetto, 2024) # Level Conditional Coherent (LCC) reconciled forecasts endo_LC <- cslcc(base = base, agg_mat = A, comb = \"wls\",                  res = res, nodes = \"auto\", CCC = FALSE,                  const = \"endogenous\")  # Combined Conditional Coherent (CCC) reconciled forecasts endo_CCC <- cslcc(base = base, agg_mat = A, comb = \"wls\",                   res = res, nodes = \"auto\", CCC = TRUE,                   const = \"endogenous\")  # Results detailed by level: # L-1: Level 1 reconciled forecasts for L1 + L3 (bottom level) # L-2: Level 2 reconciled forecasts for L2 + L3 (bottom level) # L-3: Bottom-Up reconciled forecasts info_endo <- recoinfo(endo_CCC, verbose = FALSE) info_endo$lcc #> $`L-1` #>          s-1      s-2      s-3       s-4      s-5       s-6       s-7 #> h-1 40.23685 19.31277 20.92408  9.664411 9.648359 10.739579 10.184505 #> h-2 39.64745 20.56873 19.07871 10.759321 9.809413  9.284371  9.794343 #> attr(,\"FoReco\") #> <environment: 0x150990628> #>  #> $`L-2` #>          s-1      s-2      s-3       s-4      s-5       s-6       s-7 #> h-1 41.70862 19.94714 21.76149  9.954836 9.992300 11.392087 10.369398 #> h-2 40.11832 20.24956 19.86876 10.613199 9.636364  9.899977  9.968779 #> attr(,\"FoReco\") #> <environment: 0x150bcdad8> #>  #> $`L-3` #>          s-1     s-2      s-3      s-4      s-5      s-6      s-7 #> h-1 42.37578 20.1998 22.17598 10.07051 10.12929 11.71506 10.46092 #> h-2 42.09535 21.5839 20.51145 11.22408 10.35981 10.40077 10.11068 #> attr(,\"FoReco\") #> <environment: 0x150c531e0> #>"},{"path":"https://danigiro.github.io/FoReco/reference/csmo.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional middle-out reconciliation — csmo","title":"Cross-sectional middle-out reconciliation — csmo","text":"middle-forecast reconciliation (Athanasopoulos et al., 2009) combines top-(cstd) bottom-(csbu) genuine hierarchical/grouped time series. Given base forecasts variables intermediate level \\(l\\), performs top-approach levels \\(<l\\); bottom-approach levels \\(>l\\).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csmo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional middle-out reconciliation — csmo","text":"","code":"csmo(base, agg_mat, id_rows = 1, weights, normalize = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/csmo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional middle-out reconciliation — csmo","text":"base (\\(h \\times n_l\\)) numeric matrix containing \\(l\\)-level base forecast; \\(n_l\\) number variables level \\(l\\), \\(h\\) forecast horizon. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. id_rows numeric vector indicating \\(l\\)-level rows agg_mat. weights (\\(h \\times n_b\\)) numeric matrix containing proportions bottom time series; \\(h\\) forecast horizon, \\(n_b\\) total number bottom variables. normalize TRUE (default), weights sum 1.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csmo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional middle-out reconciliation — csmo","text":"(\\(h \\times n\\)) numeric matrix cross-sectional reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csmo.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-sectional middle-out reconciliation — csmo","text":"Athanasopoulos, G., Ahmed, R. . Hyndman, R.J. (2009) Hierarchical forecasts Australian domestic tourism. International Journal Forecasting 25(1), 146–166. doi:10.1016/j.ijforecast.2008.07.004","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/csmo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional middle-out reconciliation — csmo","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY A <- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE) # (3 x 2) top base forecasts vector (simulated), forecast horizon = 3 baseL2 <- matrix(rnorm(2*3, 5), 3, 2) # Same weights for different forecast horizons fix_weights <- runif(4) reco <- csmo(base = baseL2, agg_mat = A, id_rows = 2:3, weights = fix_weights)  # Different weights for different forecast horizons h_weights <- matrix(runif(4*3), 3, 4) recoh <- csmo(base = baseL2, agg_mat = A, id_rows = 2:3, weights = h_weights)"},{"path":"https://danigiro.github.io/FoReco/reference/csprojmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","title":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","text":"function computes projection mapping matrix \\(\\mathbf{M}\\) \\(\\mathbf{G}\\), respectively, \\(\\widetilde{\\mathbf{y}} = \\mathbf{M}\\widehat{\\mathbf{y}} = \\mathbf{S}_{cs}\\mathbf{G}\\widehat{\\mathbf{y}}\\), \\(\\widetilde{\\mathbf{y}}\\) vector reconciled forecasts, \\(\\widehat{\\mathbf{y}}\\) vector base forecasts, \\(\\mathbf{S}_{cs}\\) cross-sectional structural matrix, \\(\\mathbf{M} = \\mathbf{S}_{cs}\\mathbf{G}\\). information regarding structure matrices, refer Girolimetto et al. (2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csprojmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","text":"","code":"csprojmat(agg_mat, cons_mat, comb = \"ols\", res = NULL, mat = \"M\", ...)"},{"path":"https://danigiro.github.io/FoReco/reference/csprojmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","text":"agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints: row represents constraint equation, column represents variable. matrix can full rank, meaning rows linearly independent, strict requirement, function allows redundancy constraints. comb string specifying reconciliation method. complete list, see cscov. res (\\(N \\times n\\)) optional numeric matrix containing -sample residuals. matrix used compute covariance matrices. mat string specifying matrix return: \"M\" (default) \\(\\mathbf{M}\\) \"G\" \\(\\mathbf{G}\\). ... Arguments passed cscov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csprojmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","text":"projection matrix \\(\\mathbf{M}\\) (mat = \"M\") mapping matrix \\(\\mathbf{G}\\) (mat = \"G\").","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csprojmat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/csprojmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","text":"","code":"# Cross-sectional framework A <- t(c(1,1)) # Aggregation matrix for Z = X + Y Mcs <- csprojmat(agg_mat = A, comb = \"ols\") Gcs <- csprojmat(agg_mat = A, comb = \"ols\", mat = \"G\")"},{"path":"https://danigiro.github.io/FoReco/reference/csrec.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal combination cross-sectional reconciliation — csrec","title":"Optimal combination cross-sectional reconciliation — csrec","text":"function performs optimal (least squares sense) combination cross-sectional forecast reconciliation linearly constrained (e.g., hierarchical/grouped) multiple time series (Wickramasuriya et al., 2019, Panagiotelis et al., 2022, Girolimetto Di Fonzo, 2023). reconciled forecasts calculated using either projection approach (Byron, 1978, 1979) equivalent structural approach Hyndman et al. (2011). Non-negative (Di Fonzo Girolimetto, 2023) immutable (including Zhang et al., 2023) reconciled forecasts can considered.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csrec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal combination cross-sectional reconciliation — csrec","text":"","code":"csrec(base, agg_mat, cons_mat, comb = \"ols\", res = NULL, approach = \"proj\",       nn = NULL, settings = NULL, bounds = NULL, immutable = NULL, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/csrec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal combination cross-sectional reconciliation — csrec","text":"base (\\(h \\times n\\)) numeric matrix multivariate time series (mts class) containing base forecasts reconciled; \\(h\\) forecast horizon, \\(n\\) total number time series (\\(n = n_a + n_b\\)). agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints: row represents constraint equation, column represents variable. matrix can full rank, meaning rows linearly independent, strict requirement, function allows redundancy constraints. comb string specifying reconciliation method. complete list, see cscov. res (\\(N \\times n\\)) optional numeric matrix containing -sample residuals. matrix used compute covariance matrices. approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. nn string specifying algorithm compute non-negative forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"bpv\": block principal pivoting algorithm. \"sntz\": heuristic \"set-negative--zero\" (Di Fonzo Girolimetto, 2023). settings list control parameters. nn = \"osqp\" object class osqpSettings specifying settings osqp solver. details, refer osqp documentation (Stellato et al., 2020). nn = \"bpv\" includes: ptype permutation method (\"random\" \"fixed\", default), par number full exchange rules may attempted (10, default), tol tolerance convergence criteria (sqrt(.Machine$double.eps), default), gtol gradient tolerance convergence criteria (sqrt(.Machine$double.eps), default), itmax maximum number algorithm iterations (100, default) bounds matrix (see set_bounds) 3 columns (\\(,lower,upper\\)), Column 1 represents cross-sectional series (\\(= 1, \\dots, n\\)). Columns 2 3 indicates lower lower bounds, respectively. immutable numeric vector containing column indices base forecasts (base parameter) fixed. ... Arguments passed cscov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csrec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal combination cross-sectional reconciliation — csrec","text":"(\\(h \\times n\\)) numeric matrix cross-sectional reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csrec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimal combination cross-sectional reconciliation — csrec","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Di Fonzo, T. Girolimetto, D. (2023), Spatio-temporal reconciliation solar forecasts, Solar Energy, 251, 13–29. doi:10.1016/j.solener.2023.01.003 Girolimetto, D. Di Fonzo, T. (2023), Point probabilistic forecast reconciliation general linearly constrained multiple time series, Statistical Methods & Applications, 33, 581-607. doi:10.1007/s10260-023-00738-6 . Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Panagiotelis, ., Athanasopoulos, G., Gamakumara, P. Hyndman, R.J. (2021), Forecast reconciliation: geometric view new insights bias correction, International Journal Forecasting, 37, 1, 343–359. doi:10.1016/j.ijforecast.2020.06.004 Stellato, B., Banjac, G., Goulart, P., Bemporad, . Boyd, S. (2020), OSQP: Operator Splitting solver Quadratic Programs, Mathematical Programming Computation, 12, 4, 637-672. doi:10.1007/s12532-020-00179-2 Wickramasuriya, S.L., Athanasopoulos, G. Hyndman, R.J. (2019), Optimal forecast reconciliation hierarchical grouped time series trace minimization, Journal American Statistical Association, 114, 526, 804-819. doi:10.1080/01621459.2018.1448825 Zhang, B., Kang, Y., Panagiotelis, . Li, F. (2023), Optimal reconciliation immutable forecasts, European Journal Operational Research, 308(2), 650–660. doi:10.1016/j.ejor.2022.11.035","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/csrec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal combination cross-sectional reconciliation — csrec","text":"","code":"set.seed(123) # (2 x 3) base forecasts matrix (simulated), Z = X + Y base <- matrix(rnorm(6, mean = c(20, 10, 10)), 2, byrow = TRUE) # (10 x 3) in-sample residuals matrix (simulated) res <- t(matrix(rnorm(n = 30), nrow = 3))  # Aggregation matrix for Z = X + Y A <- t(c(1,1)) reco <- csrec(base = base, agg_mat = A, comb = \"wls\", res = res)  # Zero constraints matrix for Z - X - Y = 0 C <- t(c(1, -1, -1)) reco <- csrec(base = base, cons_mat = C, comb = \"wls\", res = res)  # Non negative reconciliation # Making negative one of the base forecasts for variable Y base[1,3] <- -base[1,3] nnreco <- csrec(base = base, agg_mat = A, comb = \"wls\", res = res,                 nn = \"osqp\") recoinfo(nnreco, verbose = FALSE)$info #>     obj_val   run_time iter      pri_res status status_polish #> 1 -352.4619 2.7041e-05   25 4.230023e-24      1             1"},{"path":"https://danigiro.github.io/FoReco/reference/cssample.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional probabilistic reconciliation (sample approach) — cssample","title":"Cross-sectional probabilistic reconciliation (sample approach) — cssample","text":"Cross-sectional probabilistic reconciliation (sample approach)","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cssample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional probabilistic reconciliation (sample approach) — cssample","text":"","code":"cssample(sample, fun = csrec, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/cssample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional probabilistic reconciliation (sample approach) — cssample","text":"sample (\\(h \\times n \\times L\\)) numeric array containing base forecasts samples reconciled; \\(h\\) forecast horizon, \\(n\\) total number time series (\\(n = n_a + n_b\\)), \\(L\\) sample size. fun string specifying reconciliation function used, implemented FoReco. ... Arguments passed fun","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cssample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional probabilistic reconciliation (sample approach) — cssample","text":"distributional::dist_sample object.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cssample.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-sectional probabilistic reconciliation (sample approach) — cssample","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003 Panagiotelis, ., Gamakumara, P., Athanasopoulos, G. Hyndman, R.J. (2023), Probabilistic forecast reconciliation: Properties, evaluation score optimisation, European Journal Operational Research 306(2), 693–706. doi:10.1016/j.ejor.2022.07.040","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cssample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional probabilistic reconciliation (sample approach) — cssample","text":"","code":"set.seed(123) A <- t(c(1,1)) # Aggregation matrix for Z = X + Y  # (100 x 3) base forecasts sample (simulated) for h = 1 base_h1 <- matrix(rnorm(100*3, mean = c(20, 10, 10)), 100, byrow = TRUE) # (100 x 3) base forecasts sample (simulated) for h = 2 base_h2 <- matrix(rnorm(100*3, mean = c(20, 10, 10)), 100, byrow = TRUE) # (2 x 3 x 100) base forecasts sample array with # 2 forecast horizons, 3 time series and 100 sample base_sample <- aperm(simplify2array(list(base_h1, base_h2)), c(3,2,1))  # Optimal cross-sectional probabilistic reconciliation reco_dist_opt <- cssample(base_sample, agg_mat = A)  # Bottom-up probabilistic reconciliation reco_dist_bu <- cssample(base_sample[,-1,], agg_mat = A, fun = csbu)  # Level conditional coherent probabilistic reconciliation reco_dist_lcc <- cssample(base_sample, agg_mat = A, fun = cslcc)"},{"path":"https://danigiro.github.io/FoReco/reference/cstd.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional top-down reconciliation — cstd","title":"Cross-sectional top-down reconciliation — cstd","text":"Top-forecast reconciliation genuine hierarchical/grouped time series (Gross Sohl, 1990), forecast `Total' (top-level series, expected positive) disaggregated according proportional scheme (weights). Besides fulfilling aggregation constraint, top-reconciled forecasts respect two main properties: top-level value remains unchanged; bottom time series reconciled forecasts non-negative.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cstd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional top-down reconciliation — cstd","text":"","code":"cstd(base, agg_mat, weights, normalize = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/cstd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional top-down reconciliation — cstd","text":"base (\\(h \\times 1\\)) numeric vector containing top-level base forecast; \\(h\\) forecast horizon. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. weights (\\(h \\times n_b\\)) numeric matrix containing proportions bottom time series; \\(h\\) forecast horizon, \\(n_b\\) total number bottom variables. normalize TRUE (default), weights sum 1.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cstd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional top-down reconciliation — cstd","text":"(\\(h \\times n\\)) numeric matrix cross-sectional reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cstd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-sectional top-down reconciliation — cstd","text":"Gross, C.W. Sohl, J.E. (1990), Disaggregation methods expedite product line forecasting. Journal Forecasting 9(3), 233–254. doi:10.1002/.3980090304","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cstd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional top-down reconciliation — cstd","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY A <- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE) # (3 x 1) top base forecasts vector (simulated), forecast horizon = 3 topf <- rnorm(3, 10) # Same weights for different forecast horizons fix_weights <- runif(4) reco <- cstd(base = topf, agg_mat = A, weights = fix_weights)  # Different weights for different forecast horizons h_weights <- matrix(runif(4*3), 3, 4) recoh <- cstd(base = topf, agg_mat = A, weights = h_weights)"},{"path":"https://danigiro.github.io/FoReco/reference/cstools.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional reconciliation tools — cstools","title":"Cross-sectional reconciliation tools — cstools","text":"useful tools cross-sectional forecast reconciliation linearly constrained (e.g., hierarchical/grouped) multiple time series.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cstools.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional reconciliation tools — cstools","text":"","code":"cstools(agg_mat, cons_mat, sparse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/cstools.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional reconciliation tools — cstools","text":"agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints: row represents constraint equation, column represents variable. matrix can full rank, meaning rows linearly independent, strict requirement, function allows redundancy constraints. sparse Option return sparse matrices (default TRUE).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cstools.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional reconciliation tools — cstools","text":"list four elements: dim vector containing information number series complete system (n), upper levels (na) bottom level (nb). agg_mat cross-sectional aggregation matrix. strc_mat cross-sectional structural matrix. cons_mat cross-sectional zero constraints matrix.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cstools.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional reconciliation tools — cstools","text":"","code":"# Cross-sectional framework # One level hierarchy A = [1 1] A <- matrix(1, 1, 2) obj <- cstools(agg_mat = A)"},{"path":"https://danigiro.github.io/FoReco/reference/ctboot.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal joint block bootstrap — ctboot","title":"Cross-temporal joint block bootstrap — ctboot","text":"Joint block bootstrap generating probabilistic base forecasts take account correlation variables different temporal aggregation orders (Girolimetto et al. 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctboot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal joint block bootstrap — ctboot","text":"","code":"ctboot(model_list, boot_size, agg_order, block_size = 1, seed = NULL)"},{"path":"https://danigiro.github.io/FoReco/reference/ctboot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal joint block bootstrap — ctboot","text":"model_list list \\(n\\) elements, one cross-sectional series. elements list \\((k^\\ast+m)\\) base forecasts models ordered lowest frequency (temporally aggregated) highest frequency. simulate() function model available implemented according package forecast, following mandatory parameters: object, innov, future, nsim. boot_size number bootstrap replicates. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). block_size Block size bootstrap, typically equivalent forecast horizon temporally aggregated series. seed integer seed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctboot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal joint block bootstrap — ctboot","text":"list two elements: seed used sample errors list \\(\\text{boot\\_size}\\) matrix size (\\(n\\times(k^\\ast+m)\\text{block\\_size}\\)) matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctboot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-temporal joint block bootstrap — ctboot","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2023), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40(3), 1134-1151. doi:10.1016/j.ijforecast.2023.10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctbu.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal bottom-up reconciliation — ctbu","title":"Cross-temporal bottom-up reconciliation — ctbu","text":"Cross-temporal bottom-reconciled forecasts series temporal aggregation level computed appropriate summation high-frequency bottom base forecasts \\(\\widehat{\\mathbf{B}}^{[1]}\\): $$\\widetilde{\\mathbf{X}} = \\mathbf{S}_{cs}\\widehat{\\mathbf{B}}^{[1]}\\mathbf{S}'_{te},$$ \\(\\mathbf{S}_{cs}\\) \\(\\mathbf{S}_{te}\\) cross-sectional temporal structural matrices, respectively.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctbu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal bottom-up reconciliation — ctbu","text":"","code":"ctbu(base, agg_mat, agg_order, tew = \"sum\", sntz = FALSE, round = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/ctbu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal bottom-up reconciliation — ctbu","text":"base (\\(n_b \\times hm\\)) numeric matrix containing high-frequency bottom base forecasts; \\(n_b\\) total number high-frequency bottom variables, \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). sntz Logical. TRUE, negative base forecasts set zero (Di Fonzo Girolimetto, 2023) applying bottom-. Default FALSE. round Logical. TRUE, base forecasts rounded applying bottom-reconciliation. Default FALSE.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctbu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal bottom-up reconciliation — ctbu","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctbu.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-temporal bottom-up reconciliation — ctbu","text":"Di Fonzo, T. Girolimetto, D. (2023), Spatio-temporal reconciliation solar forecasts, Solar Energy, 251, 13–29. doi:10.1016/j.solener.2023.01.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctbu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-temporal bottom-up reconciliation — ctbu","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y A <- t(c(1,1)) # (2 x 4) high frequency bottom base forecasts matrix (simulated), # agg_order = 4 (annual-quarterly) hfbts <- matrix(rnorm(4*2, 2.5), 2, 4)  reco <- ctbu(base = hfbts, agg_mat = A, agg_order = 4)  # Non negative reconciliation hfbts[1,4] <- -hfbts[1,4] # Making negative one of the quarterly values for X nnreco <- ctbu(base = hfbts, agg_mat = A, agg_order = 4, sntz = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/ctcov.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal covariance matrix approximation — ctcov","title":"Cross-temporal covariance matrix approximation — ctcov","text":"function provides approximation cross-temporal base forecasts errors covariance matrix using different reconciliation methods (Di Fonzo Girolimetto, 2023, Girolimetto et al., 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctcov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal covariance matrix approximation — ctcov","text":"","code":"ctcov(comb = \"ols\", n = NULL, agg_mat = NULL, agg_order = NULL, res = NULL,       tew = \"sum\", mse = TRUE, shrink_fun = shrink_estim, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/ctcov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal covariance matrix approximation — ctcov","text":"comb string specifying reconciliation method. ordinary least squares reconciliation: \"ols\" (default) - identity error covariance. weighted least squares reconciliation: \"str\" - structural variances. \"csstr\" - cross-sectional structural variances. \"testr\" - temporal structural variances. \"wlsh\" - hierarchy variances (uses res). \"wlsv\" - series variances (uses res). generalized least squares (uses res) reconciliation: \"acov\" - series auto-covariance. \"bdshr\"/\"bdsam\" - shrunk/sample block diagonal cross-sectional covariance. \"Sshr\"/\"Ssam\" - series shrunk/sample covariance. \"shr\"/\"sam\" - shrunk/sample covariance. \"hbshr\"/\"hbsam\" - shrunk/sample high frequency bottom time series covariance. \"bshr\"/\"bsam\" - shrunk/sample bottom time series covariance. \"hshr\"/\"hsam\" - shrunk/sample high frequency covariance. Others (reconciliation): \"bu\" - bottom-covariance. n Cross-sectional number variables. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default). ... used.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctcov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal covariance matrix approximation — ctcov","text":"(\\(n(k^\\ast+m) \\times n(k^\\ast+m)\\)) symmetric matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctcov.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-temporal covariance matrix approximation — ctcov","text":"Di Fonzo, T. Girolimetto, D. (2023), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004 Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctcov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-temporal covariance matrix approximation — ctcov","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y A <- t(c(1,1)) # (3 x 70) in-sample residuals matrix (simulated), # agg_order = 4 (annual-quarterly) res <- rbind(rnorm(70), rnorm(70), rnorm(70))  cov1 <- ctcov(\"ols\", n = 3, agg_order = 4)                     # OLS methods cov2 <- ctcov(\"str\", agg_mat = A, agg_order = 4)               # STR methods cov3 <- ctcov(\"csstr\", agg_mat = A, agg_order = 4)             # CSSTR methods cov4 <- ctcov(\"testr\", n = 3, agg_order = 4)                   # TESTR methods cov5 <- ctcov(\"wlsv\", agg_order = 4, res = res)                # WLSv methods cov6 <- ctcov(\"wlsh\", agg_order = 4, res = res)                # WLSh methods cov7 <- ctcov(\"shr\", agg_order = 4, res = res)                 # SHR methods cov8 <- ctcov(\"sam\", agg_order = 4, res = res)                 # SAM methods cov9 <- ctcov(\"acov\", agg_order = 4, res = res)                # ACOV methods cov10 <- ctcov(\"Sshr\", agg_order = 4, res = res)               # Sshr methods cov11 <- ctcov(\"Ssam\", agg_order = 4, res = res)               # Ssam methods cov12 <- ctcov(\"hshr\", agg_order = 4, res = res)               # Hshr methods cov13 <- ctcov(\"hsam\", agg_order = 4, res = res)               # Hsam methods cov14 <- ctcov(\"hbshr\", agg_mat = A, agg_order = 4, res = res) # HBshr methods cov15 <- ctcov(\"hbsam\", agg_mat = A, agg_order = 4, res = res) # HBsam methods cov16 <- ctcov(\"bshr\", agg_mat = A, agg_order = 4, res = res)  # Bshr methods cov17 <- ctcov(\"bsam\", agg_mat = A, agg_order = 4, res = res)  # Bsam methods cov18 <- ctcov(\"bdshr\", agg_order = 4, res = res)              # BDshr methods cov19 <- ctcov(\"bdsam\", agg_order = 4, res = res)              # BDsam methods  # Custom covariance matrix ctcov.ols2 <- function(comb, x) diag(x) cov20 <- ctcov(comb = \"ols2\", x = 21) # == ctcov(\"ols\", n = 3, agg_order = 4)"},{"path":"https://danigiro.github.io/FoReco/reference/ctgauss.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal Gaussian probabilistic reconciliation — ctgauss","title":"Temporal Gaussian probabilistic reconciliation — ctgauss","text":"Temporal Gaussian probabilistic reconciliation","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctgauss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal Gaussian probabilistic reconciliation — ctgauss","text":"","code":"ctgauss(   base,   agg_mat,   cons_mat,   agg_order,   comb = \"ols\",   comb_base = comb,   res = NULL,   tew = \"sum\",   approach = \"proj\",   reduce_form = FALSE,   ... )"},{"path":"https://danigiro.github.io/FoReco/reference/ctgauss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal Gaussian probabilistic reconciliation — ctgauss","text":"base (\\(n \\times h(k^\\ast+m)\\)) numeric matrix containing base forecasts reconciled; \\(n\\) total number variables, \\(m\\) maximum aggregation order, \\(k^\\ast\\) sum chosen subset \\(p - 1\\) factors \\(m\\) (excluding \\(m\\) ), \\(h\\) forecast horizon lowest frequency time series. row identifies time series, forecasts row ordered lowest frequency (temporally aggregated) highest frequency. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints: row represents constraint equation, column represents variable. matrix can full rank, meaning rows linearly independent, strict requirement, function allows redundancy constraints. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see ctcov. comb_base string specifying reconciliation method. complete list, see ctcov. res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. reduce_form logical parameter indicating whether function return full distribution (FALSE, default) distribution corresponding high-frequency bottom time series (TRUE). ... Arguments passed ctcov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctgauss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal Gaussian probabilistic reconciliation — ctgauss","text":"distributional::dist_multivariate_normal object.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctgauss.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Temporal Gaussian probabilistic reconciliation — ctgauss","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Panagiotelis, ., Gamakumara, P., Athanasopoulos, G. Hyndman, R.J. (2023), Probabilistic forecast reconciliation: Properties, evaluation score optimisation, European Journal Operational Research 306(2), 693–706. doi:10.1016/j.ejor.2022.07.040","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctgauss.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal Gaussian probabilistic reconciliation — ctgauss","text":"","code":"set.seed(123) # (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4 base <- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4)))) # (3 x 70) in-sample residuals matrix (simulated) res <- rbind(rnorm(70), rnorm(70), rnorm(70)) A <- t(c(1,1)) reco_dist <- ctgauss(base = base, res = res, agg_mat = A, agg_order = 4)"},{"path":"https://danigiro.github.io/FoReco/reference/ctlcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","title":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","text":"function implements forecast reconciliation procedure inspired original proposal Hollyman et al. (2021) cross-temporal hierarchies. Level conditional coherent reconciled forecasts conditional (.e., constrained ) base forecasts specific upper level hierarchy (exogenous constraints). also allows handling linear constraints linking variables endogenously (Di Fonzo Girolimetto, 2022). function can calculate Combined Conditional Coherent (CCC) forecasts simple averages Level-Conditional Coherent (LCC) bottom-reconciled forecasts, either endogenous exogenous constraints.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctlcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","text":"","code":"ctlcc(base, agg_mat, nodes = \"auto\", agg_order, comb = \"ols\", res = NULL,       CCC = TRUE, const = \"exogenous\", hfbts = NULL, tew = \"sum\",       approach = \"proj\", nn = NULL, settings = NULL, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/ctlcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","text":"base (\\(n \\times h(k^\\ast+m)\\)) numeric matrix containing base forecasts reconciled; \\(n\\) total number variables, \\(m\\) maximum aggregation order, \\(k^\\ast\\) sum chosen subset \\(p - 1\\) factors \\(m\\) (excluding \\(m\\) ), \\(h\\) forecast horizon lowest frequency time series. row identifies time series, forecasts row ordered lowest frequency (temporally aggregated) highest frequency. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. nodes (\\(L \\times 1\\)) numeric vector indicating number variables upper \\(L\\) levels hierarchy. default value string \"auto\" calculates number variables level. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see ctcov. res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. CCC logical value indicating whether Combined Conditional Coherent reconciled forecasts reconciliation include bottom-forecasts (TRUE, default), . const string specifying reconciliation constraints: \"exogenous\" (default): Fixes top level sub-hierarchy. \"endogenous\": Coherently revises top bottom levels. hfbts (\\(n \\times mh\\)) numeric matrix containing high frequency bottom base forecasts defined user. parameter can omitted base forecasts used (see Di Fonzo Girolimetto, 2024). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. nn string specifying algorithm compute non-negative forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"bpv\": block principal pivoting algorithm. \"sntz\": heuristic \"set-negative--zero\" (Di Fonzo Girolimetto, 2023). settings list control parameters. nn = \"osqp\" object class osqpSettings specifying settings osqp solver. details, refer osqp documentation (Stellato et al., 2020). nn = \"bpv\" includes: ptype permutation method (\"random\" \"fixed\", default), par number full exchange rules may attempted (10, default), tol tolerance convergence criteria (sqrt(.Machine$double.eps), default), gtol gradient tolerance convergence criteria (sqrt(.Machine$double.eps), default), itmax maximum number algorithm iterations (100, default) ... Arguments passed ctcov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctlcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctlcc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Di Fonzo, T. Girolimetto, D. (2024), Forecast combination-based forecast reconciliation: Insights extensions, International Journal Forecasting, 40(2), 490–514. doi:10.1016/j.ijforecast.2022.07.001 Di Fonzo, T. Girolimetto, D. (2023b) Spatio-temporal reconciliation solar forecasts. Solar Energy 251, 13–29. doi:10.1016/j.solener.2023.01.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Hollyman, R., Petropoulos, F. Tipping, M.E. (2021), Understanding forecast reconciliation. European Journal Operational Research, 294, 149–160. doi:10.1016/j.ejor.2021.01.017 Stellato, B., Banjac, G., Goulart, P., Bemporad, . Boyd, S. (2020), OSQP: Operator Splitting solver Quadratic Programs, Mathematical Programming Computation, 12, 4, 637-672. doi:10.1007/s12532-020-00179-2","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctlcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY A <- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE) # (7 x 7) base forecasts matrix (simulated), agg_order = 4 base <- rbind(rnorm(7, rep(c(40, 20, 10), c(1, 2, 4))),               rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4)))) # (7 x 70) in-sample residuals matrix (simulated) res <- matrix(rnorm(70*7), nrow = 7) # (4 x 4) Naive high frequency bottom base forecasts vector: # all forecasts are set equal to 2.5 naive <- matrix(2.5, 4, 4)  ## EXOGENOUS CONSTRAINTS (Hollyman et al., 2021) # Level Conditional Coherent (LCC) reconciled forecasts exo_LC <- ctlcc(base = base, agg_mat = A, agg_order = 4, comb = \"wlsh\", nn = \"osqp\",                 hfbts = naive, res = res, nodes = \"auto\", CCC = FALSE)  # Combined Conditional Coherent (CCC) reconciled forecasts exo_CCC <- ctlcc(base = base, agg_mat = A, agg_order = 4, comb = \"wlsh\",                 hfbts = naive, res = res, nodes = \"auto\", CCC = TRUE)  # Results detailed by level: info_exo <- recoinfo(exo_CCC, verbose = FALSE) # info_exo$lcc  ## ENDOGENOUS CONSTRAINTS (Di Fonzo and Girolimetto, 2024) # Level Conditional Coherent (LCC) reconciled forecasts endo_LC <- ctlcc(base = base, agg_mat = A, agg_order = 4, comb = \"wlsh\",                  res = res, nodes = \"auto\", CCC = FALSE,                  const = \"endogenous\")  # Combined Conditional Coherent (CCC) reconciled forecasts endo_CCC <- ctlcc(base = base, agg_mat = A, agg_order = 4, comb = \"wlsh\",                   res = res, nodes = \"auto\", CCC = TRUE,                   const = \"endogenous\")  # Results detailed by level: info_endo <- recoinfo(endo_CCC, verbose = FALSE) # info_endo$lcc"},{"path":"https://danigiro.github.io/FoReco/reference/ctmatrix_layouts.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert between horizon-stacked and cross-temporal layouts — as_ctmatrix","title":"Convert between horizon-stacked and cross-temporal layouts — as_ctmatrix","text":"functions convert matrix two canonical layouts used cross-temporal reconciliation. Let \\(m\\) maximum temporal aggregation order \\(k^\\ast\\) sum subset \\((p-1)\\) proper factors \\(m\\) (excluding \\(m\\)); let \\(h\\) forecast horizon lowest frequency series (e.g., aggregated temporal forecast horizon) \\(n\\) number variables: Horizon-stacked layout (cross-temporal version): \\(h \\times n(k^\\ast + m)\\) matrix rows aggregated temporal forecast horizons, values row ordered lowest frequency (temporally aggregated) highest frequency grouped variable. Cross-temporal layout: \\(n \\times h(k^\\ast + m)\\) matrix rows variables, horizons temporal block appear consecutively. rows variables, values row ordered lowest frequency (temporally aggregated) highest frequency. , as_ctmatrix converts \\((h \\times n(k^\\ast+m))\\) horizon-stacked \\((n \\times h(k^\\ast+m))\\) cross-temporal matrix; as_hstack_ctlayout performs inverse transform.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctmatrix_layouts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert between horizon-stacked and cross-temporal layouts — as_ctmatrix","text":"","code":"as_ctmatrix(hmat, agg_order, n, row_names = NULL)  as_hstack_ctlayout(ctmat, agg_order)"},{"path":"https://danigiro.github.io/FoReco/reference/ctmatrix_layouts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert between horizon-stacked and cross-temporal layouts — as_ctmatrix","text":"hmat \\(h \\times n(k^\\ast+m)\\) numeric matrix horizon-stacked layout (cross-temporal version). agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). n Cross-sectional number variables. row_names Optional character vector length n row names cross-temporal output as_ctmatrix(). NULL (default) custom names assigned. ctmat \\(n \\times h(k^\\ast+m)\\) numeric matrix cross-temporal layout.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctmatrix_layouts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert between horizon-stacked and cross-temporal layouts — as_ctmatrix","text":"as_ctmatrix returns \\(n \\times h(k^\\ast+m)\\) numeric matrix cross-temporal layout. as_hstack_ctlayout returns \\(h \\times n(k^\\ast+m)\\) numeric matrix horizon-stacked layout (cross-temporal version).","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctmatrix_layouts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert between horizon-stacked and cross-temporal layouts — as_ctmatrix","text":"","code":"h <- 2   # horizons n <- 3   # variables m <- 4   # temporal aggregation order kt <- tetools(m)$dim[\"kt\"]  # Build a horizon-stacked matrix: h rows, n * k_t columns input_ct <- matrix(seq_len(h * n * kt), nrow = n, byrow = TRUE)  hmat <- as_hstack_ctlayout(input_ct, agg_order = m) ctmat <- as_ctmatrix(hmat, agg_order = m, n = n) # all.equal(ctmat, input_ct, check.attributes = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/ctmo.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal middle-out reconciliation — ctmo","title":"Cross-temporal middle-out reconciliation — ctmo","text":"cross-temporal middle-forecast reconciliation combines top-(cttd) bottom-(ctbu) methods cross-temporal framework genuine hierarchical/grouped time series. Given base forecasts intermediate cross-sectional level \\(l\\) aggregation order \\(k\\), performs top-approach aggregation orders \\(\\geq k\\) cross-sectional levels \\(\\geq l\\); bottom-approach, otherwise.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctmo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal middle-out reconciliation — ctmo","text":"","code":"ctmo(base, agg_mat, agg_order, id_rows = 1, order = max(agg_order),      weights, tew = \"sum\", normalize = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/ctmo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal middle-out reconciliation — ctmo","text":"base (\\(n_l \\times hk\\)) numeric matrix containing \\(l\\)-level base forecasts temporal aggregation order \\(k\\); \\(n_l\\) number variables level \\(l\\), \\(k\\) aggregation order (factor \\(m\\), \\(1<k<m\\)), \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). id_rows numeric vector indicating \\(l\\)-level rows agg_mat. order intermediate fixed aggregation order \\(k\\). weights (\\(n_b \\times hm\\)) numeric matrix containing proportions high-frequency bottom time series; \\(n_b\\) total number high-frequency bottom variables, \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). normalize TRUE (default), weights sum 1.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctmo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal middle-out reconciliation — ctmo","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctmo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-temporal middle-out reconciliation — ctmo","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY A <- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE) # (2 x 6) base forecasts matrix (simulated), forecast horizon = 3 # and intermediate aggregation order k = 2 (max agg order = 4) baseL2k2 <- rbind(rnorm(3*2, 5), rnorm(3*2, 5))  # Same weights for different forecast horizons, agg_order = 4 fix_weights <- matrix(runif(4*4), 4, 4) reco <- ctmo(base = baseL2k2, id_rows = 2:3, agg_mat = A,              order = 2, agg_order = 4, weights = fix_weights)  # Different weights for different forecast horizons h_weights <- matrix(runif(4*4*3), 4, 3*4) recoh <- ctmo(base = baseL2k2, id_rows = 2:3, agg_mat = A,              order = 2, agg_order = 4, weights = h_weights)"},{"path":"https://danigiro.github.io/FoReco/reference/ctprojmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","title":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","text":"function computes projection mapping matrix \\(\\mathbf{M}\\) \\(\\mathbf{G}\\), respectively, \\(\\widetilde{\\mathbf{y}} = \\mathbf{M}\\widehat{\\mathbf{y}} = \\mathbf{S}_{ct}\\mathbf{G}\\widehat{\\mathbf{y}}\\), \\(\\widetilde{\\mathbf{y}}\\) vector reconciled forecasts, \\(\\widehat{\\mathbf{y}}\\) vector base forecasts, \\(\\mathbf{S}_{ct}\\) cross-temporal structural matrix, \\(\\mathbf{M} = \\mathbf{S}_{ct}\\mathbf{G}\\). information regarding structure matrices, refer Girolimetto et al. (2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctprojmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","text":"","code":"ctprojmat(agg_mat, cons_mat, agg_order, comb = \"ols\", res = NULL,           mat = \"M\", tew = \"sum\", ...)"},{"path":"https://danigiro.github.io/FoReco/reference/ctprojmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","text":"agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints: row represents constraint equation, column represents variable. matrix can full rank, meaning rows linearly independent, strict requirement, function allows redundancy constraints. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see ctcov. res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. mat string specifying matrix return: \"M\" (default) \\(\\mathbf{M}\\) \"G\" \\(\\mathbf{G}\\). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). ... Arguments passed ctcov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctprojmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","text":"projection matrix \\(\\mathbf{M}\\) (mat = \"M\") mapping matrix \\(\\mathbf{G}\\) (mat = \"G\").","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctprojmat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctprojmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","text":"","code":"# Cross-temporal framework (Z = X + Y, annual-quarterly) A <- t(c(1,1)) # Aggregation matrix for Z = X + Y Mct <- ctprojmat(agg_mat = A, agg_order = 4, comb = \"ols\") Gct <- ctprojmat(agg_mat = A, agg_order = 4, comb = \"ols\", mat = \"G\")"},{"path":"https://danigiro.github.io/FoReco/reference/ctrec.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal combination cross-temporal reconciliation — ctrec","title":"Optimal combination cross-temporal reconciliation — ctrec","text":"function performs optimal (least squares sense) combination cross-temporal forecast reconciliation (Di Fonzo Girolimetto 2023a, Girolimetto et al. 2023). reconciled forecasts calculated using either projection approach (Byron, 1978, 1979) equivalent structural approach Hyndman et al. (2011). Non-negative (Di Fonzo Girolimetto, 2023) immutable reconciled forecasts can considered.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctrec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal combination cross-temporal reconciliation — ctrec","text":"","code":"ctrec(base, agg_mat, cons_mat, agg_order, comb = \"ols\", res = NULL,       tew = \"sum\", approach = \"proj\", nn = NULL, settings = NULL,       bounds = NULL, immutable = NULL, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/ctrec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal combination cross-temporal reconciliation — ctrec","text":"base (\\(n \\times h(k^\\ast+m)\\)) numeric matrix containing base forecasts reconciled; \\(n\\) total number variables, \\(m\\) maximum aggregation order, \\(k^\\ast\\) sum chosen subset \\(p - 1\\) factors \\(m\\) (excluding \\(m\\) ), \\(h\\) forecast horizon lowest frequency time series. row identifies time series, forecasts row ordered lowest frequency (temporally aggregated) highest frequency. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints: row represents constraint equation, column represents variable. matrix can full rank, meaning rows linearly independent, strict requirement, function allows redundancy constraints. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see ctcov. res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. nn string specifying algorithm compute non-negative forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"bpv\": block principal pivoting algorithm. \"sntz\": heuristic \"set-negative--zero\" (Di Fonzo Girolimetto, 2023). settings list control parameters. nn = \"osqp\" object class osqpSettings specifying settings osqp solver. details, refer osqp documentation (Stellato et al., 2020). nn = \"bpv\" includes: ptype permutation method (\"random\" \"fixed\", default), par number full exchange rules may attempted (10, default), tol tolerance convergence criteria (sqrt(.Machine$double.eps), default), gtol gradient tolerance convergence criteria (sqrt(.Machine$double.eps), default), itmax maximum number algorithm iterations (100, default) bounds matrix (see set_bounds) 5 columns (\\(,k,j,lower,upper\\)), Column 1 represents cross-sectional series (\\(= 1, \\dots, n\\)). Column 2 represents temporal aggregation order (\\(k = m,\\dots,1\\)). Column 3 represents temporal forecast horizon (\\(j = 1,\\dots,m/k\\)). Columns 4 5 indicates lower lower bounds, respectively. immutable matrix three columns (\\(,k,j\\)), Column 1 represents cross-sectional series (\\(= 1, \\dots, n\\)). Column 2 represents temporal aggregation order (\\(k = m,\\dots,1\\)). Column 3 represents temporal forecast horizon (\\(j = 1,\\dots,m/k\\)). example, working quarterly multivariate time series (\\(n = 3\\)): t(c(1, 4, 1)) - Fix one step ahead annual forecast first time series. t(c(2, 1, 2)) - Fix two step ahead quarterly forecast second time series. ... Arguments passed ctcov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctrec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal combination cross-temporal reconciliation — ctrec","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctrec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimal combination cross-temporal reconciliation — ctrec","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Di Fonzo, T. Girolimetto, D. (2023a), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004 Di Fonzo, T. Girolimetto, D. (2023), Spatio-temporal reconciliation solar forecasts, Solar Energy, 251, 13–29. doi:10.1016/j.solener.2023.01.003 Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Stellato, B., Banjac, G., Goulart, P., Bemporad, . Boyd, S. (2020), OSQP: Operator Splitting solver Quadratic Programs, Mathematical Programming Computation, 12, 4, 637-672. doi:10.1007/s12532-020-00179-2","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctrec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal combination cross-temporal reconciliation — ctrec","text":"","code":"set.seed(123) # (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4 base <- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4)))) # (3 x 70) in-sample residuals matrix (simulated) res <- rbind(rnorm(70), rnorm(70), rnorm(70))  A <- t(c(1,1)) # Aggregation matrix for Z = X + Y m <- 4 # from quarterly to annual temporal aggregation reco <- ctrec(base = base, agg_mat = A, agg_order = m,               comb = \"wlsv\", res = res)  C <- t(c(1, -1, -1)) # Zero constraints matrix for Z - X - Y = 0 reco <- ctrec(base = base, cons_mat = C, agg_order = m,               comb = \"wlsv\", res = res)  # Immutable reconciled forecasts # Fix all the quarterly forecasts of the second variable. imm_mat <- expand.grid(i = 2, k = 1, j = 1:4) immreco <- ctrec(base = base, cons_mat = C, agg_order = m, comb = \"wlsv\",                  res = res, immutable = imm_mat)  # Non negative reconciliation # Making negative one of the quarterly base forecasts for variable X base[2,7] <- -2*base[2,7] nnreco <- ctrec(base = base, cons_mat = C, agg_order = m, comb = \"wlsv\",                 res = res, nn = \"osqp\") recoinfo(nnreco, verbose = FALSE)$info #>     obj_val   run_time iter      pri_res status status_polish #> 1 -635.7645 8.6916e-05   25 8.881784e-16      1             1"},{"path":"https://danigiro.github.io/FoReco/reference/ctsample.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal probabilistic reconciliation (sample approach) — ctsample","title":"Cross-temporal probabilistic reconciliation (sample approach) — ctsample","text":"Cross-temporal probabilistic reconciliation (sample approach)","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctsample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal probabilistic reconciliation (sample approach) — ctsample","text":"","code":"ctsample(sample, agg_order, fun = ctrec, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/ctsample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal probabilistic reconciliation (sample approach) — ctsample","text":"sample (\\(n \\times h(k^\\ast + m) \\times L\\)) numeric array containing base forecasts samples reconciled; \\(n\\) total number variables, \\(m\\) max. order temporal aggregation, \\(k^\\ast\\) sum (subset ) (\\(p-1\\)) factors \\(m\\),  excluding \\(m\\), \\(h\\) forecast horizon lowest frequency time series, \\(L\\) sample size. row identifies time series, forecasts row ordered lowest frequency (temporally aggregated) highest frequency. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). fun string specifying reconciliation function used, implemented FoReco. ... Arguments passed fun","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctsample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal probabilistic reconciliation (sample approach) — ctsample","text":"distributional::dist_sample object.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctsample.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-temporal probabilistic reconciliation (sample approach) — ctsample","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003 Panagiotelis, ., Gamakumara, P., Athanasopoulos, G. Hyndman, R.J. (2023), Probabilistic forecast reconciliation: Properties, evaluation score optimisation, European Journal Operational Research 306(2), 693–706. doi:10.1016/j.ejor.2022.07.040","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctsample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-temporal probabilistic reconciliation (sample approach) — ctsample","text":"","code":"set.seed(123) A <- t(c(1,1)) # Aggregation matrix for Z = X + Y m <- 4 # from quarterly to annual temporal aggregation  # (100 x 14) base forecasts sample matrix (simulated), m = 4, h = 2, n = 3 sample <- simplify2array(lapply(1:100, function(x){   rbind(rnorm(14, rep(c(20, 10, 5), 2*c(1, 2, 4))),         rnorm(14, rep(c(10, 5, 2.5), 2*c(1, 2, 4))),         rnorm(14, rep(c(10, 5, 2.5), 2*c(1, 2, 4)))) })) # (3 x 70) in-sample residuals matrix (simulated) res <- rbind(rnorm(70), rnorm(70), rnorm(70))  # Optimal cross-sectional probabilistic reconciliation reco_dist_opt <- ctsample(sample, agg_order = m, agg_mat = A, res = res, comb = \"bdshr\")  # Bottom-up probabilistic reconciliation reco_dist_bu <- ctsample(sample[-1,-c(1:6), ], agg_order = m, agg_mat = A, fun = ctbu)  # Level conditional coherent probabilistic reconciliation reco_dist_lcc <- ctsample(sample, agg_order = m, agg_mat = A, fun = ctlcc)"},{"path":"https://danigiro.github.io/FoReco/reference/cttd.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal top-down reconciliation — cttd","title":"Cross-temporal top-down reconciliation — cttd","text":"Top-forecast reconciliation cross-temporal hierarchical/grouped time series, forecast `Total' (top-level series, expected positive) disaggregated according proportional scheme (weights). Besides fulfilling aggregation constraint, top-reconciled forecasts respect two main properties: top-level value remains unchanged; bottom time series reconciled forecasts non-negative.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cttd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal top-down reconciliation — cttd","text":"","code":"cttd(base, agg_mat, agg_order, weights, tew = \"sum\", normalize = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/cttd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal top-down reconciliation — cttd","text":"base (\\(hm \\times 1\\)) numeric vector containing top- \\(m\\) temporal aggregated level base forecasts; \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). weights (\\(n_b \\times hm\\)) numeric matrix containing proportions high-frequency bottom time series; \\(n_b\\) total number high-frequency bottom variables, \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). normalize TRUE (default), weights sum 1.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cttd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal top-down reconciliation — cttd","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cttd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-temporal top-down reconciliation — cttd","text":"","code":"set.seed(123) # (3 x 1) top base forecasts vector (simulated), forecast horizon = 3 topf <- rnorm(3, 10) A <- t(c(1,1)) # Aggregation matrix for Z = X + Y  # Same weights for different forecast horizons, agg_order = 4 fix_weights <- matrix(runif(4*2), 2, 4) reco <- cttd(base = topf, agg_mat = A, agg_order = 4, weights = fix_weights)  # Different weights for different forecast horizons h_weights <- matrix(runif(4*2*3), 2, 3*4) recoh <- cttd(base = topf, agg_mat = A, agg_order = 4, weights = h_weights)"},{"path":"https://danigiro.github.io/FoReco/reference/cttools.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal reconciliation tools — cttools","title":"Cross-temporal reconciliation tools — cttools","text":"useful tools cross-temporal forecast reconciliation linearly constrained (e.g., hierarchical/grouped) multiple time series.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cttools.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal reconciliation tools — cttools","text":"","code":"cttools(agg_mat, cons_mat, agg_order, tew = \"sum\", fh = 1, sparse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/cttools.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal reconciliation tools — cttools","text":"agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints: row represents constraint equation, column represents variable. matrix can full rank, meaning rows linearly independent, strict requirement, function allows redundancy constraints. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). fh Forecast horizon lowest frequency (temporally aggregated) time series (default 1). sparse Option return sparse matrices (default TRUE).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cttools.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal reconciliation tools — cttools","text":"list four elements: dim vector containing information number series complete system (n), upper levels (na) bottom level (nb), maximum aggregation order  (m), number factor (p), partial (ks) total sum (kt) factors. set vector temporal aggregation orders (decreasing order). agg_mat cross-temporal aggregation matrix. strc_mat cross-temporal structural matrix. cons_mat cross-temporal zero constraints matrix.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cttools.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-temporal reconciliation tools — cttools","text":"","code":"# Cross-temporal framework A <- t(c(1,1)) # Aggregation matrix for Z = X + Y m <- 4 # from quarterly to annual temporal aggregation cttools(agg_mat = A, agg_order = m) #> $dim #>  n na nb  m  p ks kt  #>  3  1  2  4  3  3  7  #>  #> $set #> [1] 4 2 1 #>  #> $agg_mat #> 13 x 8 sparse Matrix of class \"dgCMatrix\" #>                       #>  [1,] 1 1 1 1 1 1 1 1 #>  [2,] 1 1 . . 1 1 . . #>  [3,] . . 1 1 . . 1 1 #>  [4,] 1 . . . 1 . . . #>  [5,] . 1 . . . 1 . . #>  [6,] . . 1 . . . 1 . #>  [7,] . . . 1 . . . 1 #>  [8,] 1 1 1 1 . . . . #>  [9,] 1 1 . . . . . . #> [10,] . . 1 1 . . . . #> [11,] . . . . 1 1 1 1 #> [12,] . . . . 1 1 . . #> [13,] . . . . . . 1 1 #>  #> $strc_mat #> 21 x 8 sparse Matrix of class \"dgCMatrix\" #>                       #>  [1,] 1 1 1 1 1 1 1 1 #>  [2,] 1 1 . . 1 1 . . #>  [3,] . . 1 1 . . 1 1 #>  [4,] 1 . . . 1 . . . #>  [5,] . 1 . . . 1 . . #>  [6,] . . 1 . . . 1 . #>  [7,] . . . 1 . . . 1 #>  [8,] 1 1 1 1 . . . . #>  [9,] 1 1 . . . . . . #> [10,] . . 1 1 . . . . #> [11,] 1 . . . . . . . #> [12,] . 1 . . . . . . #> [13,] . . 1 . . . . . #> [14,] . . . 1 . . . . #> [15,] . . . . 1 1 1 1 #> [16,] . . . . 1 1 . . #> [17,] . . . . . . 1 1 #> [18,] . . . . 1 . . . #> [19,] . . . . . 1 . . #> [20,] . . . . . . 1 . #> [21,] . . . . . . . 1 #>  #> $cons_mat #> 13 x 21 sparse Matrix of class \"dgCMatrix\" #>                                                             #>  [1,] . . .  1  .  .  . . . . -1  .  .  . . . . -1  .  .  . #>  [2,] . . .  .  1  .  . . . .  . -1  .  . . . .  . -1  .  . #>  [3,] . . .  .  .  1  . . . .  .  . -1  . . . .  .  . -1  . #>  [4,] . . .  .  .  .  1 . . .  .  .  . -1 . . .  .  .  . -1 #>  [5,] 1 . . -1 -1 -1 -1 . . .  .  .  .  . . . .  .  .  .  . #>  [6,] . 1 . -1 -1  .  . . . .  .  .  .  . . . .  .  .  .  . #>  [7,] . . 1  .  . -1 -1 . . .  .  .  .  . . . .  .  .  .  . #>  [8,] . . .  .  .  .  . 1 . . -1 -1 -1 -1 . . .  .  .  .  . #>  [9,] . . .  .  .  .  . . 1 . -1 -1  .  . . . .  .  .  .  . #> [10,] . . .  .  .  .  . . . 1  .  . -1 -1 . . .  .  .  .  . #> [11,] . . .  .  .  .  . . . .  .  .  .  . 1 . . -1 -1 -1 -1 #> [12,] . . .  .  .  .  . . . .  .  .  .  . . 1 . -1 -1  .  . #> [13,] . . .  .  .  .  . . . .  .  .  .  . . . 1  .  . -1 -1 #>"},{"path":"https://danigiro.github.io/FoReco/reference/df2aggmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional aggregation matrix of a dataframe — df2aggmat","title":"Cross-sectional aggregation matrix of a dataframe — df2aggmat","text":"function allows user easily build (\\(n_a \\times n_b\\)) cross-sectional aggregation matrix starting data frame.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/df2aggmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional aggregation matrix of a dataframe — df2aggmat","text":"","code":"df2aggmat(formula, data, sep = \"_\", sparse = TRUE, top_label = \"Total\",           verbose = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/df2aggmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional aggregation matrix of a dataframe — df2aggmat","text":"formula Specification hierarchical structure: grouped hierarchies specified using ~ g1 * g2 nested hierarchies specified using ~ parent / child. Mixtures two formulations also possible, like ~ g1 * (grandparent / parent / child). data dataset column contains values variables formula row identifies bottom level time series. sep Character separate names aggregated series, (default \"_\"). sparse Option return sparse matrices (default TRUE). top_label Label top level variable (default \"Total\"). verbose TRUE (default), hierarchy informations printed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/df2aggmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional aggregation matrix of a dataframe — df2aggmat","text":"(na x nb) matrix.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/df2aggmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional aggregation matrix of a dataframe — df2aggmat","text":"","code":"## Balanced hierarchy #         T #    |--------| #    A        B #  |---|   |--|--| # AA   AB  BA BB BC # Names of the bottom level variables data_bts <- data.frame(X1 = c(\"A\", \"A\", \"B\", \"B\", \"B\"),                        X2 = c(\"A\", \"B\", \"A\", \"B\", \"C\"),                        stringsAsFactors = FALSE) # Cross-sectional aggregation matrix agg_mat <- df2aggmat(~ X1 / X2, data_bts, sep = \"\", verbose = FALSE)  ## Unbalanced hierarchy #                 T #       |---------|---------| #       A         B         C #     |---|     |---|     |---| #    AA   AB   BA   BB   CA   CB #  |----|         |----| # AAA  AAB       BBA  BBB # Names of the bottom level variables data_bts <- data.frame(X1 = c(\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"C\", \"C\"),                        X2 = c(\"A\", \"A\", \"B\", \"A\", \"B\", \"B\", \"A\", \"B\"),                        X3 = c(\"A\", \"B\", NA, NA, \"A\", \"B\", NA, NA),                        stringsAsFactors = FALSE) # Cross-sectional aggregation matrix agg_mat <- df2aggmat(~ X1 / X2 / X3, data_bts, sep = \"\", verbose = FALSE)  ## Group of two hierarchies #     T          T         T | A  | B  | C #  |--|--|  X  |---|  ->  ---+----+----+---- #  A  B  C     M   F       M | AM | BM | CM #                          F | AF | BF | CF # Names of the bottom level variables data_bts <- data.frame(X1 = c(\"A\", \"A\", \"B\", \"B\", \"C\", \"C\"),                        Y1 = c(\"M\", \"F\", \"M\", \"F\", \"M\", \"F\"),                        stringsAsFactors = FALSE) # Cross-sectional aggregation matrix agg_mat <- df2aggmat(~ Y1 * X1, data_bts, sep = \"\", verbose = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":null,"dir":"Reference","previous_headings":"","what":"Heuristic cross-temporal reconciliation — tcsrec","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"tcsrec replicates procedure Kourentzes Athanasopoulos (2019): () time series forecasts temporal aggregation order reconciled using temporal hierarchies; (ii) time--time cross-sectional reconciliation performed; (iii) projection matrices obtained step (ii) averaged used cross-sectionally reconcile forecasts obtained step (). cstrec, order application two reconciliation steps (temporal first, cross-sectional), inverted compared tcsrec (Di Fonzo Girolimetto, 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"","code":"# First-temporal-then-cross-sectional forecast reconciliation tcsrec(base, cslist, telist, res = NULL, avg = \"KA\")  # First-cross-sectional-then-temporal forecast reconciliation cstrec(base, cslist, telist, res = NULL)"},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"base (\\(n \\times h(k^\\ast+m)\\)) numeric matrix containing base forecasts reconciled; \\(n\\) total number variables, \\(m\\) maximum aggregation order, \\(k^\\ast\\) sum chosen subset \\(p - 1\\) factors \\(m\\) (excluding \\(m\\) ), \\(h\\) forecast horizon lowest frequency time series. row identifies time series, forecasts row ordered lowest frequency (temporally aggregated) highest frequency. cslist list elements cross-sectional reconciliation. See csrec complete list (excluded base res). telist list elements temporal reconciliation. See terec complete list (excluded base res). res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. avg avg = \"KA\" (default), final projection matrix \\(\\mathbf{M}\\) one proposed Kourentzes Athanasopoulos (2019), otherwise calculated simple average involved projection matrices step 2 procedure (see Di Fonzo Girolimetto, 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"two-step heuristic reconciliation allows considering non negativity constraints first step. means non-negativity guaranteed final reconciled values.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"Di Fonzo, T. Girolimetto, D. (2023), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004 Kourentzes, N. Athanasopoulos, G. (2019), Cross-temporal coherent forecasts Australian tourism, Annals Tourism Research, 75, 393-409. doi:10.1016/j.annals.2019.02.001","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"","code":"set.seed(123) # (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4 base <- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4)))) # (3 x 70) in-sample residuals matrix (simulated) res <- rbind(rnorm(70), rnorm(70), rnorm(70))  A <- t(c(1,1)) # Aggregation matrix for Z = X + Y m <- 4 # from quarterly to annual temporal aggregation  rtcs <- tcsrec(base = base,                cslist = list(agg_mat = A, comb = \"shr\"),                telist = list(agg_order = m, comb = \"wlsv\"),                res = res)  rcst <- tcsrec(base = base,                cslist = list(agg_mat = A, comb = \"shr\"),                telist = list(agg_order = m, comb = \"wlsv\"),                res = res)"},{"path":"https://danigiro.github.io/FoReco/reference/itagdp.html","id":null,"dir":"Reference","previous_headings":"","what":"Italian Quarterly National Accounts — itagdp","title":"Italian Quarterly National Accounts — itagdp","text":"subset data used Girolimetto et al. (2023) Italian Quarterly National Accounts (output, income expenditure sides) spanning period 2000:Q1-2019:Q4.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/itagdp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Italian Quarterly National Accounts — itagdp","text":"","code":"# 21 time series of the Italian Quarterly National Accounts itagdp  # 'agg_mat' and 'cons_mat' for the output side outside  # 'agg_mat' and 'cons_mat' for the expenditure side expside  # 'agg_mat' and 'cons_mat' for the income side incside  # zero constraints matrix encompassing output, expenditure and income sides gdpconsmat"},{"path":"https://danigiro.github.io/FoReco/reference/itagdp.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Italian Quarterly National Accounts — itagdp","text":"itagdp \\((80 \\times 21)\\) ts object, corresponding 21 time series Italian Quarterly National Accounts (2000:Q1-2019:Q4). outside, income expenditure lists two elements: agg_mat contains \\((1 \\times 2)\\), \\((2 \\times 4)\\), \\((6 \\times 8)\\) aggregation matrix according output, income expenditure side, respectively. cons_mat contains \\((1 \\times 3)\\), \\((2 \\times 6)\\), \\((6 \\times 14)\\) zero constraints matrix according output, income expenditure side, respectively. gdpconsmat complete \\((9 \\times 21)\\) zero constraints matrix encompassing output, expenditure income sides.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/itagdp.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Italian Quarterly National Accounts — itagdp","text":"https://ec.europa.eu/eurostat/web/national-accounts/","code":""},{"path":"https://danigiro.github.io/FoReco/reference/itagdp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Italian Quarterly National Accounts — itagdp","text":"Girolimetto, D. Di Fonzo, T. (2023), Point probabilistic forecast reconciliation general linearly constrained multiple time series, Statistical Methods & Applications, 33, 581-607. doi:10.1007/s10260-023-00738-6 .","code":""},{"path":"https://danigiro.github.io/FoReco/reference/iterec.html","id":null,"dir":"Reference","previous_headings":"","what":"Iterative cross-temporal reconciliation — iterec","title":"Iterative cross-temporal reconciliation — iterec","text":"function performs iterative procedure described Di Fonzo Girolimetto (2023), produces cross-temporally reconciled forecasts alternating forecast reconciliation along one single dimension (either cross-sectional temporal) iteration step.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/iterec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Iterative cross-temporal reconciliation — iterec","text":"","code":"iterec(base, cslist, telist, res = NULL, itmax = 100, tol = 1e-5,        type = \"tcs\", norm = \"inf\", verbose = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/iterec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Iterative cross-temporal reconciliation — iterec","text":"base (\\(n \\times h(k^\\ast+m)\\)) numeric matrix containing base forecasts reconciled; \\(n\\) total number variables, \\(m\\) maximum aggregation order, \\(k^\\ast\\) sum chosen subset \\(p - 1\\) factors \\(m\\) (excluding \\(m\\) ), \\(h\\) forecast horizon lowest frequency time series. row identifies time series, forecasts row ordered lowest frequency (temporally aggregated) highest frequency. cslist list elements cross-sectional reconciliation. See csrec complete list (excluded base res). telist list elements temporal reconciliation. See terec complete list (excluded base res). res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. itmax Max number iteration (100, default). tol Convergence tolerance (1e-5, default). type string specifying uni-dimensional reconciliation order: temporal cross-sectional (\"tcs\") cross-sectional temporal (\"cst\"). norm Norm used calculate temporal cross-sectional incoherence: infinity norm (\"inf\", default), one norm (\"one\"), 2-norm (\"two\"). verbose TRUE, reconciliation information printed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/iterec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Iterative cross-temporal reconciliation — iterec","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/iterec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Iterative cross-temporal reconciliation — iterec","text":"Di Fonzo, T. Girolimetto, D. (2023), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/iterec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Iterative cross-temporal reconciliation — iterec","text":"","code":"set.seed(123) # (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4 base <- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4)))) # (3 x 70) in-sample residuals matrix (simulated) res <- rbind(rnorm(70), rnorm(70), rnorm(70))  A <- t(c(1,1)) # Aggregation matrix for Z = X + Y m <- 4 # from quarterly to annual temporal aggregation  rite <- iterec(base = base,                cslist = list(agg_mat = A, comb = \"shr\"),                telist = list(agg_order = m, comb = \"wlsv\"),                res = res) #> ── Iterative heuristic cross-temporal forecast reconciliation ────────────────── #> Legend: i = iteration; s = step. Norm = \"inf\". #>  #>   i.s |        Temporal | Cross-sectional | #>     0 |            3.36 |            1.79 | #>   1.1 |            0.00 |            1.91 | #>   1.2 |        2.02e-01 |            0.00 | #>   2.1 |            0.00 |        2.42e-02 | #>   2.2 |        2.56e-03 |            0.00 | #>   3.1 |            0.00 |        3.18e-04 | #>   3.2 |        3.37e-05 |            0.00 | #>   4.1 |            0.00 |        4.50e-06 | #>   4.2 |        4.62e-07 |            0.00 | #>  #> ✔ Convergence achieved at iteration 4. #> ────────────────────────────────────────────────────────────────────────────────"},{"path":"https://danigiro.github.io/FoReco/reference/lcmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","title":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","text":"function transforms general (possibly redundant) zero constraints matrix linear combination (aggregation) matrix \\(\\mathbf{}_{cs}\\). working general linearly constrained multiple (\\(n\\)-variate) time series, getting linear combination matrix \\(\\mathbf{}_{cs}\\) critical step obtain structural-like representation $$\\mathbf{C}_{cs} = [\\mathbf{} \\quad -\\mathbf{}],$$ \\(\\mathbf{C}_{cs}\\) full rank zero constraints matrix (Girolimetto Di Fonzo, 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/lcmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","text":"","code":"lcmat(cons_mat, method = \"rref\", tol = sqrt(.Machine$double.eps),        verbose = FALSE, sparse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/lcmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","text":"cons_mat (\\(r \\times n\\)) numeric matrix representing cross-sectional zero constraints. method Method use: \"rref\" Reduced Row Echelon Form Gauss-Jordan elimination (default), \"qr\" (pivoting) QR decomposition (Strang, 2019). tol Tolerance \"rref\" \"qr\" method. verbose TRUE, intermediate steps printed (default FALSE). sparse Option return sparse matrix (default TRUE).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/lcmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","text":"list two elements: () linear combination (aggregation) matrix (agg_mat) (ii) vector column permutations (pivot).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/lcmat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","text":"Girolimetto, D. Di Fonzo, T. (2023), Point probabilistic forecast reconciliation general linearly constrained multiple time series, Statistical Methods & Applications, 33, 581-607. doi:10.1007/s10260-023-00738-6 . Strang, G. (2019), Linear algebra learning data, Wellesley, Cambridge Press.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/lcmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","text":"","code":"## Two hierarchy sharing the same top-level variable, but not sharing the bottom variables #        X            X #    |-------|    |-------| #    A       B    C       D #  |---| # A1   A2 # 1) X = C + D, # 2) X = A + B, # 3) A = A1 + A2. cons_mat <- matrix(c(1,-1,-1,0,0,0,0,                1,0,0,-1,-1,0,0,                0,0,0,1,0,-1,-1), nrow = 3, byrow = TRUE) obj <- lcmat(cons_mat = cons_mat, verbose = TRUE) #> ! A pivot is performed. Remember to apply the pivot also to the base forecast. #> ℹ E.g. `base[, pivot]` in cross-sectional or `base[pivot, ]` in cross-temporal. agg_mat <- obj$agg_mat # linear combination matrix pivot <- obj$pivot # Pivot vector"},{"path":"https://danigiro.github.io/FoReco/reference/recoinfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Informations on the reconciliation process — recoinfo","title":"Informations on the reconciliation process — recoinfo","text":"function extracts reconciliation information output reconciled function implemented FoReco.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/recoinfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Informations on the reconciliation process — recoinfo","text":"","code":"recoinfo(x, verbose = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/recoinfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Informations on the reconciliation process — recoinfo","text":"x output reconciliation function implemented FoReco. verbose TRUE (defaults), reconciliation information printed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/recoinfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Informations on the reconciliation process — recoinfo","text":"list containing following reconciliation process information: rfun reconciliation function. cs_n cross-sectional number variables. te_set set temporal aggregation orders. forecast_horizon forecast horizon (temporal cross-temporal frameworks, temporally aggregated series). framework reconciliation framework (cross-sectional, temporal cross-temporal). info non-negative reconciled forecast convergence information. lcc list level conditional reconciled forecasts (+ BU) cslcc, telcc ctlcc. nn TRUE, forecasts negative. comb covariance approximation.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/reshape2matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a horizon-stacked matrix to a cross-temporal form matrix — reshape2matrix","title":"Convert a horizon-stacked matrix to a cross-temporal form matrix — reshape2matrix","text":"function arranges (\\(h \\times n(k^\\ast+m)\\)) \"horizon-stacked\" matrix (\\(n \\times h(k^\\ast+m)\\)) cross-temporal form matrix reshaping horizons appear consecutively temporal block.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/reshape2matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a horizon-stacked matrix to a cross-temporal form matrix — reshape2matrix","text":"","code":"reshape2matrix(hmat, agg_order, n, row_names = NULL)"},{"path":"https://danigiro.github.io/FoReco/reference/reshape2matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a horizon-stacked matrix to a cross-temporal form matrix — reshape2matrix","text":"hmat (\\(h \\times n(k^\\ast+m)\\)) numeric matrix horizon-stacked form; \\(n\\) total number variables, \\(m\\) max. order temporal aggregation, \\(k^\\ast\\) sum (subset ) (\\(p-1\\)) factors \\(m\\), excluding \\(m\\), \\(h\\) forecast horizon lowest frequency time series. row identifies forecast horizon, forecasts row ordered lowest frequency (temporally aggregated) highest frequency grouped variable. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). n Cross-sectional number variables. row_names Optional character vector length n giving names rows output matrix. NULL (default), row names assigned.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/reshape2matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a horizon-stacked matrix to a cross-temporal form matrix — reshape2matrix","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal form: row identifies variable, forecasts row ordered lowest frequency (temporally aggregated) highest frequency.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/reshape2matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a horizon-stacked matrix to a cross-temporal form matrix — reshape2matrix","text":"","code":"# Example with small dimensions h <- 2   # horizons n <- 3   # series m <- 4   # temporal aggregation order kt <- tetools(m)$dim[\"kt\"]  # Build a horizon-stacked matrix: h rows, n * k_t columns hmat <- matrix(seq_len(h * n * kt), nrow = h)  # Convert to cross-temporal layout: n rows, h * k_t columns out <- reshape2matrix(hmat, agg_order = m, n = n) out #>     k-4 h-1 k-4 h-2 k-2 h-1 k-2 h-2 k-2 h-3 k-2 h-4 k-1 h-1 k-1 h-2 k-1 h-3 #> s-1       1       2       3       5       4       6       7       9      11 #> s-2      15      16      17      19      18      20      21      23      25 #> s-3      29      30      31      33      32      34      35      37      39 #>     k-1 h-4 k-1 h-5 k-1 h-6 k-1 h-7 k-1 h-8 #> s-1      13       8      10      12      14 #> s-2      27      22      24      26      28 #> s-3      41      36      38      40      42"},{"path":"https://danigiro.github.io/FoReco/reference/reshape2vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a horizon-stacked matrix to a temporal form vector — reshape2vector","title":"Convert a horizon-stacked matrix to a temporal form vector — reshape2vector","text":"function arranges (\\(h \\times (k^\\ast+m)\\)) \"horizon-stacked\" matrix (\\(h(k^\\ast + m) \\times 1\\)) temporal form vector reshaping horizons appear consecutively temporal block.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/reshape2vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a horizon-stacked matrix to a temporal form vector — reshape2vector","text":"","code":"reshape2vector(hmat, agg_order)"},{"path":"https://danigiro.github.io/FoReco/reference/reshape2vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a horizon-stacked matrix to a temporal form vector — reshape2vector","text":"hmat (\\(h \\times (k^\\ast+m)\\)) numeric matrix horizon-stacked form; \\(m\\) max. order temporal aggregation, \\(k^\\ast\\) sum (subset ) (\\(p-1\\)) factors \\(m\\), excluding \\(m\\), \\(h\\) forecast horizon lowest frequency time series. row identifies forecast horizon, forecasts row ordered lowest frequency (temporally aggregated) highest frequency. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/reshape2vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a horizon-stacked matrix to a temporal form vector — reshape2vector","text":"(\\(h(k^\\ast + m) \\times 1\\)) numeric vector temporal form: values ordered lowest frequency highest frequency.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/reshape2vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a horizon-stacked matrix to a temporal form vector — reshape2vector","text":"","code":"# Example with small dimensions h <- 2   # horizons m <- 4   # temporal aggregation order kt <- tetools(m)$dim[\"kt\"]  # Build a horizon-stacked matrix: h rows, k_t columns hmat <- matrix(seq_len(h * kt), nrow = h)  # Convert to temporal form: h * k_t vector out <- reshape2vector(hmat, agg_order = m) out #> k-4 h-1 k-4 h-2 k-2 h-1 k-2 h-2 k-2 h-3 k-2 h-4 k-1 h-1 k-1 h-2 k-1 h-3 k-1 h-4  #>       1       2       3       5       4       6       7       9      11      13  #> k-1 h-5 k-1 h-6 k-1 h-7 k-1 h-8  #>       8      10      12      14"},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":null,"dir":"Reference","previous_headings":"","what":"One-step and multi-step residuals — res2matrix","title":"One-step and multi-step residuals — res2matrix","text":"functions can used arrange residuals reconcile temporal cross-temporal forecasts. res2matrix  takes input set temporal cross-temporal residuals re-organizes matrix rows correspond different forecast horizons, capturing temporal dimension. Meanwhile, columns ordered based specific arrangement described Di Fonzo Girolimetto (2023). Please see as_hstack_ctlayout as_hstack_telayout. arrange_hres takes input list multi-step residuals designed organize accordance time order (Girolimetto et al. 2023). applied, function ensures sequence multi-step residuals aligns chronological order occurred.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"One-step and multi-step residuals — res2matrix","text":"","code":"res2matrix(res, agg_order)  arrange_hres(list_res)"},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"One-step and multi-step residuals — res2matrix","text":"res (\\(n \\times N(k^\\ast+m)\\)) numeric matrix (cross-temporal framework) (\\(N(k^\\ast+m) \\times 1\\)) numeric vector (temporal framework) representing -sample residuals temporal frequencies ordered lowest frequency highest frequency (columns) variable (rows). agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). list_res list \\(H\\) multi-step residuals. element list can either (\\(T \\times 1\\)) vector (temporal framework) (\\(T \\times n\\)) matrix (cross-temporal framework).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"One-step and multi-step residuals — res2matrix","text":"res2matrix returns (\\(N \\times n(k^\\ast + m)\\)) matrix, \\(n = 1\\) temporal framework. arrange_hres returns (\\(N(k^\\ast+m) \\times 1\\)) vector (temporal framework) (\\(n \\times N(k^\\ast+m)\\)) matrix  (cross-temporal framework) multi-step residuals.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"One-step and multi-step residuals — res2matrix","text":"Let \\(Z_t\\), \\(t=1,\\dots,T\\), univariate time series. can define multi-step residuals us $$\\widehat{\\varepsilon}_{h,t} = Z_{t+h} - \\widehat{Z}_{t+h|t} \\qquad h \\le t \\le T-h$$ \\(\\widehat{Z}_{t+h|t}\\) \\(h\\)-step fitted value, calculated \\(h\\)-step ahead forecast condition information time \\(t\\). Given list errors different steps $$\\left([\\widehat{\\varepsilon}_{1,1}, \\; \\dots, \\; \\widehat{\\varepsilon}_{1,T}], \\dots, [\\widehat{\\varepsilon}_{H,1}, \\; \\dots, \\; \\widehat{\\varepsilon}_{H,T}]\\right),$$ arrange_hres returns \\(T\\)-vector residuals, organized following way: $$[\\varepsilon_{1,1} \\; \\varepsilon_{2,2} \\; \\dots \\; \\varepsilon_{H,H} \\; \\varepsilon_{1,H+1} \\; \\dots \\; \\varepsilon_{H,T-H}]'$$ similar organisation can apply multivariate time series.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"One-step and multi-step residuals — res2matrix","text":"Di Fonzo, T. Girolimetto, D. (2023), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004 Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"One-step and multi-step residuals — res2matrix","text":"","code":"h <- 10 agg_order <- 4 tmp <- tetools(agg_order) kt <- tmp$dim[\"kt\"]  # Simulate vector (temporal case) vec <- rnorm(kt*h) out <- res2matrix(vec, agg_order) # matrix h x kt #> Warning: `res2matrix()` was deprecated in FoReco 1.0. #> ℹ Please use `FoReco::as_hstack_telayout()` or `FoReco::as_hstack_ctlayout()`.  # Simulate (n x kt) matrix (cross-temporal case) with n = 3 mat <- rbind(rnorm(kt*h), rnorm(kt*h), rnorm(kt*h)) out <- res2matrix(mat, agg_order) # matrix h x (3*kt)  # Input: 4 (forecast horizons) vectors with 4*10 elements input <-  list(rnorm(4*10), rnorm(4*10), rnorm(4*10), rnorm(4*10)) # Output: 1 vector with 4*10 elements out <- arrange_hres(input)  # Matrix version input <-  list(matrix(rnorm(4*10*3), 4*10), matrix(rnorm(4*10*3), 4*10),                matrix(rnorm(4*10*3), 4*10), matrix(rnorm(4*10*3), 4*10)) out <- arrange_hres(input)"},{"path":"https://danigiro.github.io/FoReco/reference/set_bounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Set bounds for bounded forecast reconciliation — set_bounds","title":"Set bounds for bounded forecast reconciliation — set_bounds","text":"function defines bounds matrix considering cross-sectional, temporal, cross-temporal frameworks. output matrix can used input bounds parameter functions csrec, terec, ctrec, perform bounded reconciliations.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/set_bounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set bounds for bounded forecast reconciliation — set_bounds","text":"","code":"set_bounds(n, k, h, lb = -Inf, ub = Inf, approach = \"osqp\", bounds = NULL)"},{"path":"https://danigiro.github.io/FoReco/reference/set_bounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set bounds for bounded forecast reconciliation — set_bounds","text":"n (\\(b \\times 1\\)) vector representing \\(\\)th cross-sectional series (\\(= 1, \\dots, n\\)), \\(b\\) number bounds set. k (\\(b \\times 1\\)) vector specifying temporal aggregation orders (\\(k = m, \\dots, 1\\)). h (\\(b \\times 1\\)) vector representing forecast horizons (\\(j = 1, \\dots, m/k\\)). lb, ub (\\(b \\times 1\\)) vector lower upper bounds. approach string specifying algorithm compute bounded reconciled forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"sftb\": heuristic \"set-forecasts--bounds\", adjusts reconciled forecasts within specified bounds without optimization. bounds matrix previous bounds added. specified, new bounds computed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/set_bounds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set bounds for bounded forecast reconciliation — set_bounds","text":"numeric matrix representing computed bounds, can : Cross-sectional (\\(b \\times 3\\)) matrix cross-sectional reconciliation (csrec). Temporal (\\(b \\times 4\\)) matrix temporal reconciliation (terec). Cross-temporal (\\(b \\times 5\\)) matrix cross-temporal reconciliation (ctrec).","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/set_bounds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set bounds for bounded forecast reconciliation — set_bounds","text":"","code":"# Example 1 # Two cross-sectional series (i = 2,3), # with each series required to be between 0 and 1. n <- c(2, 3) lb <- c(0, 0) ub <- c(1,1) bounds_mat <- set_bounds(n = c(2, 3),                          lb = rep(0, 2), # or lb = 0                          ub = rep(1, 2)) # or ub = 1  # Example 2 # All the monthly values are between 0 and 1. bounds_mat <- set_bounds(k = rep(1, 12),  # or k = 1                          h = 1:12,                          lb = rep(0, 12), # or lb = 0                          ub = rep(1, 12)) # or ub = 1  # Example 3 # For two cross-sectional series (i = 2,3), # all the monthly values are between 0 and 1. bounds_mat <- set_bounds(n = rep(c(2, 3), each = 12),                          k = 1,                          h = rep(1:12, 2),                          lb = 0, # or lb = 0                          ub = 1) # or ub = 1"},{"path":"https://danigiro.github.io/FoReco/reference/shrink_estim.html","id":null,"dir":"Reference","previous_headings":"","what":"Shrinkage of the covariance matrix — shrink_estim","title":"Shrinkage of the covariance matrix — shrink_estim","text":"Shrinkage covariance matrix according Schäfer Strimmer (2005).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/shrink_estim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shrinkage of the covariance matrix — shrink_estim","text":"","code":"shrink_estim(x, mse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/shrink_estim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shrinkage of the covariance matrix — shrink_estim","text":"x numeric matrix containing residuals. mse TRUE (default), residuals used compute covariance matrix mean-corrected.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/shrink_estim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shrinkage of the covariance matrix — shrink_estim","text":"shrunk covariance matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/shrink_estim.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Shrinkage of the covariance matrix — shrink_estim","text":"Schäfer, J.L. Strimmer, K. (2005), shrinkage approach large-scale covariance matrix estimation implications functional genomics, Statistical Applications Genetics Molecular Biology, 4, 1","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/shrink_oasd.html","id":null,"dir":"Reference","previous_headings":"","what":"Shrinkage of the covariance matrix using the Oracle approximation — shrink_oasd","title":"Shrinkage of the covariance matrix using the Oracle approximation — shrink_oasd","text":"Shrinkage covariance matrix according Oracle Approximating Shrinkage (OAS) Chen et al. (2009) Ando Xiao (2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/shrink_oasd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shrinkage of the covariance matrix using the Oracle approximation — shrink_oasd","text":"","code":"shrink_oasd(x, mse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/shrink_oasd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shrinkage of the covariance matrix using the Oracle approximation — shrink_oasd","text":"x numeric matrix containing -sample residuals. mse TRUE (default), residuals used compute covariance matrix mean-corrected.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/shrink_oasd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shrinkage of the covariance matrix using the Oracle approximation — shrink_oasd","text":"shrunk covariance matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/shrink_oasd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Shrinkage of the covariance matrix using the Oracle approximation — shrink_oasd","text":"Ando, S., Xiao, M. (2023), High-dimensional covariance matrix estimation: shrinkage toward diagonal target. IMF Working Papers, 2023(257), A001. Chen, Y., Wiesel, ., Hero, . O. (2009), Shrinkage estimation high dimensional covariance matrices, 2009 IEEE international conference acoustics, speech signal processing, 2937–2940. IEEE.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/teboot.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal joint block bootstrap — teboot","title":"Temporal joint block bootstrap — teboot","text":"Joint block bootstrap generating probabilistic base forecasts take account correlation different temporal aggregation orders (Girolimetto et al. 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/teboot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal joint block bootstrap — teboot","text":"","code":"teboot(model_list, boot_size, agg_order, block_size = 1, seed = NULL)"},{"path":"https://danigiro.github.io/FoReco/reference/teboot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal joint block bootstrap — teboot","text":"model_list list \\((k^\\ast+m)\\) base forecasts models ordered lowest frequency (temporally aggregated) highest frequency. simulate() function model available implemented according package forecast, following mandatory parameters: object, innov, future, nsim. boot_size number bootstrap replicates. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). block_size Block size bootstrap, typically equivalent forecast horizon temporally aggregated series. seed integer seed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/teboot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal joint block bootstrap — teboot","text":"list two elements: seed used sample errors (\\(\\text{boot\\_size}\\times (k^\\ast+m)\\text{block\\_size}\\)) matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/teboot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Temporal joint block bootstrap — teboot","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2023), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40(3), 1134-1151. doi:10.1016/j.ijforecast.2023.10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tebu.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal bottom-up reconciliation — tebu","title":"Temporal bottom-up reconciliation — tebu","text":"Temporal bottom-reconciled forecasts temporal aggregation level computed appropriate aggregation high-frequency base forecasts, \\(\\widehat{\\mathbf{x}}^{[1]}\\): $$\\widetilde{\\mathbf{x}} = \\mathbf{S}_{te}\\widehat{\\mathbf{x}}^{[1]},$$ \\(\\mathbf{S}_{te}\\) temporal structural matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tebu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal bottom-up reconciliation — tebu","text":"","code":"tebu(base, agg_order, tew = \"sum\", sntz = FALSE, round = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/tebu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal bottom-up reconciliation — tebu","text":"base (\\(hm \\times 1\\)) numeric vector containing high-frequency base forecasts; \\(m\\) max. temporal aggregation order, \\(h\\) forecast horizon lowest frequency time series. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). sntz Logical. TRUE, negative base forecasts set zero (Di Fonzo Girolimetto, 2023) applying bottom-. Default FALSE. round Logical. TRUE, base forecasts rounded applying bottom-reconciliation. Default FALSE.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tebu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal bottom-up reconciliation — tebu","text":"(\\(h(k^\\ast+m) \\times 1\\)) numeric vector temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tebu.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Temporal bottom-up reconciliation — tebu","text":"Di Fonzo, T. Girolimetto, D. (2023), Spatio-temporal reconciliation solar forecasts, Solar Energy, 251, 13–29. doi:10.1016/j.solener.2023.01.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tebu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal bottom-up reconciliation — tebu","text":"","code":"set.seed(123) # (4 x 1) high frequency base forecasts vector (simulated), # agg_order = 4 (annual-quarterly) hfts <- rnorm(4, 5)  reco <- tebu(base = hfts, agg_order = 4)  # Non negative reconciliation hfts[4] <- -hfts[4] # Making negative one of the quarterly base forecasts nnreco <- tebu(base = hfts, agg_order = 4, sntz = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/tecov.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal covariance matrix approximation — tecov","title":"Temporal covariance matrix approximation — tecov","text":"function provides approximation temporal base forecasts errors covariance matrix using different reconciliation methods (see Di Fonzo Girolimetto, 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tecov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal covariance matrix approximation — tecov","text":"","code":"tecov(comb, agg_order = NULL, res = NULL, tew = \"sum\",       mse = TRUE, shrink_fun = shrink_estim, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/tecov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal covariance matrix approximation — tecov","text":"comb string specifying covariance approximation method. ordinary least squares reconciliation: \"ols\" (default) - identity error covariance. weighted least squares reconciliation: \"str\" - structural variances. \"wlsh\" - hierarchy variances (uses res). \"wlsv\" - series variances (uses res). generalized least squares (uses res) reconciliation: \"acov\" - series auto-covariance. \"strar1\" - structural Markov covariance. \"sar1\" - series Markov covariance. \"har1\" - hierarchy Markov covariance. \"shr\"/\"sam\" - shrunk/sample covariance. Others (reconciliation): \"bu\" - bottom-covariance. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). res (\\(N(k^\\ast+m) \\times 1\\)) optional numeric vector containing residuals ordered lowest frequency highest frequency. vector used compute come covariance matrices. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default) ... used.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tecov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal covariance matrix approximation — tecov","text":"(\\((k^\\ast+m) \\times (k^\\ast+m)\\)) symmetric matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tecov.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Temporal covariance matrix approximation — tecov","text":"Di Fonzo, T. Girolimetto, D. (2023), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tecov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal covariance matrix approximation — tecov","text":"","code":"# (7 x 70) in-sample residuals matrix (simulated), agg_order = 4 res <- rnorm(70)  cov1 <- tecov(\"ols\", agg_order = 4)                 # OLS methods cov2 <- tecov(\"str\", agg_order = 4)                 # STRC methods cov3 <- tecov(\"wlsv\", agg_order = 4, res = res)     # WLSv methods cov4 <- tecov(\"wlsh\", agg_order = 4, res = res)     # WLSh methods cov5 <- tecov(\"acov\", agg_order = 4, res = res)     # ACOV methods cov6 <- tecov(\"strar1\", agg_order = 4, res = res)   # STRAR1 methods cov7 <- tecov(\"har1\", agg_order = 4, res = res)     # HAR1 methods cov8 <- tecov(\"sar1\", agg_order = 4, res = res)     # SAR1 methods cov9 <- tecov(\"shr\", agg_order = 4, res = res)      # SHR methods cov10 <- tecov(\"sam\", agg_order = 4, res = res)     # SAM methods  # Custom covariance matrix tecov.ols2 <- function(comb, x) diag(x) tecov(comb = \"ols2\", x = 7) # == tecov(\"ols\", agg_order = 4) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]    1    0    0    0    0    0    0 #> [2,]    0    1    0    0    0    0    0 #> [3,]    0    0    1    0    0    0    0 #> [4,]    0    0    0    1    0    0    0 #> [5,]    0    0    0    0    1    0    0 #> [6,]    0    0    0    0    0    1    0 #> [7,]    0    0    0    0    0    0    1"},{"path":"https://danigiro.github.io/FoReco/reference/tegauss.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal Gaussian probabilistic reconciliation — tegauss","title":"Temporal Gaussian probabilistic reconciliation — tegauss","text":"Temporal Gaussian probabilistic reconciliation","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tegauss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal Gaussian probabilistic reconciliation — tegauss","text":"","code":"tegauss(   base,   agg_order,   comb = \"ols\",   comb_base = comb,   res = NULL,   tew = \"sum\",   approach = \"proj\",   reduce_form = FALSE,   ... )"},{"path":"https://danigiro.github.io/FoReco/reference/tegauss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal Gaussian probabilistic reconciliation — tegauss","text":"base (\\(N(k^\\ast + m) \\times 1\\)) numeric vector containing base forecasts reconciled, ordered lowest highest frequency; \\(m\\) maximum aggregation order, \\(k^\\ast\\) sum chosen subset \\(p - 1\\) factors \\(m\\) (excluding \\(m\\) ) \\(h\\) forecast horizon lowest frequency time series. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see tecov. comb_base string specifying reconciliation method. complete list, see tecov. res (\\(N(k^\\ast+m) \\times 1\\)) optional numeric vector containing residuals ordered lowest frequency highest frequency. vector used compute come covariance matrices. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. reduce_form logical parameter indicating whether function return full distribution (FALSE, default) distribution corresponding high-frequency time series (TRUE). ... Arguments passed tecov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default)","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tegauss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal Gaussian probabilistic reconciliation — tegauss","text":"distributional::dist_multivariate_normal object.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tegauss.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Temporal Gaussian probabilistic reconciliation — tegauss","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Panagiotelis, ., Gamakumara, P., Athanasopoulos, G. Hyndman, R.J. (2023), Probabilistic forecast reconciliation: Properties, evaluation score optimisation, European Journal Operational Research 306(2), 693–706. doi:10.1016/j.ejor.2022.07.040","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tegauss.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal Gaussian probabilistic reconciliation — tegauss","text":"","code":"set.seed(123) # (7 x 1) base forecasts vector (simulated), m = 4 base <- rnorm(7*2, rep(c(20, 10, 5), 2*c(1, 2, 4))) # (70 x 1) in-sample residuals vector (simulated) res <- rnorm(70)  m <- 4 # from quarterly to annual temporal aggregation reco_dist <- terec(base = base, agg_order = m, comb = \"wlsv\", res = res)"},{"path":"https://danigiro.github.io/FoReco/reference/telcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Level conditional coherent reconciliation for temporal hierarchies — telcc","title":"Level conditional coherent reconciliation for temporal hierarchies — telcc","text":"function implements forecast reconciliation procedure inspired original proposal Hollyman et al. (2021) temporal hierarchies. Level conditional coherent reconciled forecasts conditional (.e., constrained ) base forecasts specific upper level hierarchy (exogenous constraints). also allows handling linear constraints linking variables endogenously (Di Fonzo Girolimetto, 2022). function can calculate Combined Conditional Coherent (CCC) forecasts simple averages Level-Conditional Coherent (LCC) bottom-reconciled forecasts, either endogenous exogenous constraints.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/telcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Level conditional coherent reconciliation for temporal hierarchies — telcc","text":"","code":"telcc(base, agg_order, comb = \"ols\", res = NULL, CCC = TRUE,       const = \"exogenous\", hfts = NULL, tew = \"sum\",       approach = \"proj\", nn = NULL, settings = NULL, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/telcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Level conditional coherent reconciliation for temporal hierarchies — telcc","text":"base (\\(N(k^\\ast + m) \\times 1\\)) numeric vector containing base forecasts reconciled, ordered lowest highest frequency; \\(m\\) maximum aggregation order, \\(k^\\ast\\) sum chosen subset \\(p - 1\\) factors \\(m\\) (excluding \\(m\\) ) \\(h\\) forecast horizon lowest frequency time series. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see tecov. res (\\(N(k^\\ast+m) \\times 1\\)) optional numeric vector containing residuals ordered lowest frequency highest frequency. vector used compute come covariance matrices. CCC logical value indicating whether Combined Conditional Coherent reconciled forecasts reconciliation include bottom-forecasts (TRUE, default), . const string specifying reconciliation constraints: \"exogenous\" (default): Fixes top level sub-hierarchy. \"endogenous\": Coherently revises top bottom levels. hfts (\\(mh \\times 1\\)) numeric vector containing high frequency base forecasts defined user. parameter can omitted base forecasts base used (see Di Fonzo Girolimetto, 2024). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. nn string specifying algorithm compute non-negative forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"bpv\": block principal pivoting algorithm. \"sntz\": heuristic \"set-negative--zero\" (Di Fonzo Girolimetto, 2023). settings list control parameters. nn = \"osqp\" object class osqpSettings specifying settings osqp solver. details, refer osqp documentation (Stellato et al., 2020). nn = \"bpv\" includes: ptype permutation method (\"random\" \"fixed\", default), par number full exchange rules may attempted (10, default), tol tolerance convergence criteria (sqrt(.Machine$double.eps), default), gtol gradient tolerance convergence criteria (sqrt(.Machine$double.eps), default), itmax maximum number algorithm iterations (100, default) ... Arguments passed tecov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default)","code":""},{"path":"https://danigiro.github.io/FoReco/reference/telcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Level conditional coherent reconciliation for temporal hierarchies — telcc","text":"(\\(h(k^\\ast+m) \\times 1\\)) numeric vector temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/telcc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Level conditional coherent reconciliation for temporal hierarchies — telcc","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Di Fonzo, T. Girolimetto, D. (2024), Forecast combination-based forecast reconciliation: Insights extensions, International Journal Forecasting, 40(2), 490–514. doi:10.1016/j.ijforecast.2022.07.001 Di Fonzo, T. Girolimetto, D. (2023b) Spatio-temporal reconciliation solar forecasts. Solar Energy 251, 13–29. doi:10.1016/j.solener.2023.01.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Hollyman, R., Petropoulos, F. Tipping, M.E. (2021), Understanding forecast reconciliation. European Journal Operational Research, 294, 149–160. doi:10.1016/j.ejor.2021.01.017 Stellato, B., Banjac, G., Goulart, P., Bemporad, . Boyd, S. (2020), OSQP: Operator Splitting solver Quadratic Programs, Mathematical Programming Computation, 12, 4, 637-672. doi:10.1007/s12532-020-00179-2","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/telcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Level conditional coherent reconciliation for temporal hierarchies — telcc","text":"","code":"set.seed(123) # (7 x 1) base forecasts vector (simulated), agg_order = 4 base <- rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))) # (70 x 1) in-sample residuals vector (simulated) res <- rnorm(70) # (4 x 1) Naive high frequency base forecasts vector: all forecasts are set equal to 2.5 naive <- rep(2.5, 4)  ## EXOGENOUS CONSTRAINTS # Level Conditional Coherent (LCC) reconciled forecasts exo_LC <- telcc(base = base, agg_order = 4, comb = \"wlsh\", hfts = naive,                 res = res, nodes = \"auto\", CCC = FALSE)  # Combined Conditional Coherent (CCC) reconciled forecasts exo_CCC <- telcc(base = base, agg_order = 4, comb = \"wlsh\", hfts = naive,                  res = res, nodes = \"auto\", CCC = TRUE)  # Results detailed by level: info_exo <- recoinfo(exo_CCC, verbose = FALSE) # info_exo$lcc  ## ENDOGENOUS CONSTRAINTS # Level Conditional Coherent (LCC) reconciled forecasts endo_LC <- telcc(base = base, agg_order = 4, comb = \"wlsh\", res = res,                  nodes = \"auto\", CCC = FALSE, const = \"endogenous\")  # Combined Conditional Coherent (CCC) reconciled forecasts endo_CCC <- telcc(base = base, agg_order = 4, comb = \"wlsh\", res = res,                   nodes = \"auto\", CCC = TRUE, const = \"endogenous\")  # Results detailed by level: info_endo <- recoinfo(endo_CCC, verbose = FALSE) # info_endo$lcc"},{"path":"https://danigiro.github.io/FoReco/reference/tematrix_layouts.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert between horizon-stacked and temporal layouts — as_tevector","title":"Convert between horizon-stacked and temporal layouts — as_tevector","text":"functions convert matrix two canonical layouts used temporal reconciliation. Let \\(m\\) maximum temporal aggregation order \\(k^\\ast\\) sum subset \\((p-1)\\) proper factors \\(m\\) (excluding \\(m\\)); let \\(h\\) forecast horizon lowest frequency series (e.g., aggregated temporal forecast horizon): Horizon-stacked layout (temporal version): \\(h \\times (k^\\ast + m)\\) matrix rows aggregated temporal forecast horizons, values row ordered lowest frequency (temporally aggregated) highest frequency. Temporal layout: (\\(h(k^\\ast + m) \\times 1\\)) numeric vector values ordered lowest frequency (temporally aggregated) highest frequency. , as_tevector converts \\((h \\times (k^\\ast+m))\\) horizon-stacked matrix (\\(h(k^\\ast + m) \\times 1\\)) temporal vector; as_hstack_telayout performs inverse transform.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tematrix_layouts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert between horizon-stacked and temporal layouts — as_tevector","text":"","code":"as_tevector(hmat, agg_order)  as_hstack_telayout(tevec, agg_order)"},{"path":"https://danigiro.github.io/FoReco/reference/tematrix_layouts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert between horizon-stacked and temporal layouts — as_tevector","text":"hmat \\(h \\times (k^\\ast+m)\\) numeric matrix horizon-stacked layout (temporal version). agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). tevec (\\(h(k^\\ast + m) \\times 1\\)) numeric vector temporal layout.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tematrix_layouts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert between horizon-stacked and temporal layouts — as_tevector","text":"as_tevector returns (\\(h(k^\\ast + m) \\times 1\\)) numeric vector temporal layout. as_hstack_telayout returns \\(h \\times (k^\\ast+m)\\) numeric matrix horizon-stacked layout (temporal version).","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tematrix_layouts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert between horizon-stacked and temporal layouts — as_tevector","text":"","code":"h <- 2   # horizons m <- 4   # temporal aggregation order kt <- tetools(m)$dim[\"kt\"]  # Build a horizon-stacked matrix: h rows, n * k_t columns input_te <- seq_len(h * kt)  hmat <- as_hstack_telayout(input_te, agg_order = m) tevec <- as_tevector(hmat, agg_order = m) # all.equal(tevec, input_te, check.attributes = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/temo.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal middle-out reconciliation — temo","title":"Temporal middle-out reconciliation — temo","text":"middle-forecast reconciliation temporal hierarchies combines top-(tetd) bottom-(tebu) methods. Given base forecasts intermediate temporal aggregation order \\(k\\), performs top-approach aggregation orders \\(<k\\); bottom-approach aggregation orders \\(>k\\).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/temo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal middle-out reconciliation — temo","text":"","code":"temo(base, agg_order, order = max(agg_order), weights, tew = \"sum\",      normalize = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/temo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal middle-out reconciliation — temo","text":"base (\\(hk \\times 1\\)) numeric vector containing temporal aggregated base forecasts order \\(k\\); \\(k\\) aggregation order (factor \\(m\\), \\(1<k<m\\)), \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). order intermediate fixed aggregation order \\(k\\). weights (\\(hm \\times 1\\)) numeric vector containing proportions high-frequency time series; \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). normalize TRUE (default), weights sum 1.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/temo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal middle-out reconciliation — temo","text":"(\\(h(k^\\ast+m) \\times 1\\)) numeric vector temporal reconciled forecasts.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/temo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal middle-out reconciliation — temo","text":"","code":"set.seed(123) # (6 x 1) base forecasts vector (simulated), forecast horizon = 3 # and intermediate aggregation order k = 2 (max agg order = 4) basek2 <- rnorm(3*2, 5) # Same weights for different forecast horizons fix_weights <- runif(4) reco <- temo(base = basek2, order = 2, agg_order = 4, weights = fix_weights)  # Different weights for different forecast horizons h_weights <- runif(4*3) recoh <- temo(base = basek2, order = 2, agg_order = 4, weights = h_weights)"},{"path":"https://danigiro.github.io/FoReco/reference/teprojmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Projection matrix for optimal combination temporal reconciliation — teprojmat","title":"Projection matrix for optimal combination temporal reconciliation — teprojmat","text":"function computes projection mapping matrix \\(\\mathbf{M}\\) \\(\\mathbf{G}\\), respectively, \\(\\widetilde{\\mathbf{y}} = \\mathbf{M}\\widehat{\\mathbf{y}} = \\mathbf{S}_{te}\\mathbf{G}\\widehat{\\mathbf{y}}\\), \\(\\widetilde{\\mathbf{y}}\\) vector reconciled forecasts, \\(\\widehat{\\mathbf{y}}\\) vector base forecasts, \\(\\mathbf{S}_{te}\\) temporal structural matrix, \\(\\mathbf{M} = \\mathbf{S}_{te}\\mathbf{G}\\). information regarding structure matrices, refer Girolimetto et al. (2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/teprojmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Projection matrix for optimal combination temporal reconciliation — teprojmat","text":"","code":"teprojmat(agg_order, comb = \"ols\", res = NULL, mat = \"M\", tew = \"sum\", ...)"},{"path":"https://danigiro.github.io/FoReco/reference/teprojmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Projection matrix for optimal combination temporal reconciliation — teprojmat","text":"agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see tecov. res (\\(N(k^\\ast+m) \\times 1\\)) optional numeric vector containing residuals ordered lowest frequency highest frequency. vector used compute come covariance matrices. mat string specifying matrix return: \"M\" (default) \\(\\mathbf{M}\\) \"G\" \\(\\mathbf{G}\\). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). ... Arguments passed tecov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default)","code":""},{"path":"https://danigiro.github.io/FoReco/reference/teprojmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Projection matrix for optimal combination temporal reconciliation — teprojmat","text":"projection matrix \\(\\mathbf{M}\\) (mat = \"M\") mapping matrix \\(\\mathbf{G}\\) (mat = \"G\").","code":""},{"path":"https://danigiro.github.io/FoReco/reference/teprojmat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Projection matrix for optimal combination temporal reconciliation — teprojmat","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/teprojmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Projection matrix for optimal combination temporal reconciliation — teprojmat","text":"","code":"# Temporal framework (annual-quarterly) Mte <- teprojmat(agg_order = 4, comb = \"ols\") Gte <- teprojmat(agg_order = 4, comb = \"ols\", mat = \"G\")"},{"path":"https://danigiro.github.io/FoReco/reference/terec.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal combination temporal reconciliation — terec","title":"Optimal combination temporal reconciliation — terec","text":"function performs forecast reconciliation single time series using temporal hierarchies (Athanasopoulos et al., 2017, Nystrup et al., 2020). reconciled forecasts can computed using either projection approach (Byron, 1978, 1979) equivalent structural approach Hyndman et al. (2011). Non-negative (Di Fonzo Girolimetto, 2023) immutable reconciled forecasts can considered.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/terec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal combination temporal reconciliation — terec","text":"","code":"terec(base, agg_order, comb = \"ols\", res = NULL, tew = \"sum\",       approach = \"proj\", nn = NULL, settings = NULL, bounds = NULL,       immutable = NULL, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/terec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal combination temporal reconciliation — terec","text":"base (\\(N(k^\\ast + m) \\times 1\\)) numeric vector containing base forecasts reconciled, ordered lowest highest frequency; \\(m\\) maximum aggregation order, \\(k^\\ast\\) sum chosen subset \\(p - 1\\) factors \\(m\\) (excluding \\(m\\) ) \\(h\\) forecast horizon lowest frequency time series. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see tecov. res (\\(N(k^\\ast+m) \\times 1\\)) optional numeric vector containing residuals ordered lowest frequency highest frequency. vector used compute come covariance matrices. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. nn string specifying algorithm compute non-negative forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"bpv\": block principal pivoting algorithm. \"sntz\": heuristic \"set-negative--zero\" (Di Fonzo Girolimetto, 2023). settings list control parameters. nn = \"osqp\" object class osqpSettings specifying settings osqp solver. details, refer osqp documentation (Stellato et al., 2020). nn = \"bpv\" includes: ptype permutation method (\"random\" \"fixed\", default), par number full exchange rules may attempted (10, default), tol tolerance convergence criteria (sqrt(.Machine$double.eps), default), gtol gradient tolerance convergence criteria (sqrt(.Machine$double.eps), default), itmax maximum number algorithm iterations (100, default) bounds matrix (see set_bounds) 4 columns (\\(k,j,lower,upper\\)), Column 1 represents temporal aggregation order (\\(k = m,\\dots,1\\)). Column 2 represents temporal forecast horizon (\\(j = 1,\\dots,m/k\\)). Columns 3 4 indicates lower lower bounds, respectively. immutable matrix 2 columns (\\(k,j\\)), Column 1 represents temporal aggregation order (\\(k = m,\\dots,1\\)). Column 2 represents temporal forecast horizon (\\(j = 1,\\dots,m/k\\)). example, working quarterly time series: t(c(4, 1)) - Fix one step ahead annual forecast. t(c(1, 2)) - Fix two step ahead quarterly forecast. ... Arguments passed tecov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default)","code":""},{"path":"https://danigiro.github.io/FoReco/reference/terec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal combination temporal reconciliation — terec","text":"(\\(h(k^\\ast+m) \\times 1\\)) numeric vector temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/terec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimal combination temporal reconciliation — terec","text":"Athanasopoulos, G., Hyndman, R.J., Kourentzes, N. Petropoulos, F. (2017), Forecasting Temporal Hierarchies, European Journal Operational Research, 262, 1, 60-74. doi:10.1016/j.ejor.2017.02.046 Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Di Fonzo, T. Girolimetto, D. (2023), Spatio-temporal reconciliation solar forecasts, Solar Energy, 251, 13–29. doi:10.1016/j.solener.2023.01.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Nystrup, P.,  Lindström, E., Pinson, P. Madsen, H. (2020), Temporal hierarchies autocorrelation load forecasting, European Journal Operational Research, 280, 1, 876-888. doi:10.1016/j.ejor.2019.07.061 Stellato, B., Banjac, G., Goulart, P., Bemporad, . Boyd, S. (2020), OSQP: Operator Splitting solver Quadratic Programs, Mathematical Programming Computation, 12, 4, 637-672. doi:10.1007/s12532-020-00179-2","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/terec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal combination temporal reconciliation — terec","text":"","code":"set.seed(123) # (7 x 1) base forecasts vector (simulated), m = 4 base <- rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))) # (70 x 1) in-sample residuals vector (simulated) res <- rnorm(70)  m <- 4 # from quarterly to annual temporal aggregation reco <- terec(base = base, agg_order = m, comb = \"wlsv\", res = res)  # Immutable reconciled forecast # E.g. fix all the quarterly forecasts imm_q <- expand.grid(k = 1, j = 1:4) immreco <- terec(base = base, agg_order = m, comb = \"wlsv\",                  res = res, immutable = imm_q)  # Non negative reconciliation base[7] <- -base[7] # Making negative one of the quarterly base forecasts nnreco <- terec(base = base, agg_order = m, comb = \"wlsv\",                 res = res, nn = \"osqp\") recoinfo(nnreco, verbose = FALSE)$info #>     obj_val   run_time iter      pri_res status status_polish #> 1 -421.8914 4.0874e-05   25 8.587788e-16      1             1"},{"path":"https://danigiro.github.io/FoReco/reference/tesample.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal probabilistic reconciliation (sample approach) — tesample","title":"Temporal probabilistic reconciliation (sample approach) — tesample","text":"Temporal probabilistic reconciliation (sample approach)","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tesample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal probabilistic reconciliation (sample approach) — tesample","text":"","code":"tesample(sample, agg_order, fun = terec, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/tesample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal probabilistic reconciliation (sample approach) — tesample","text":"sample (\\(L \\times h(k^\\ast + m)\\)) numeric matrix containing base forecasts samples reconciled; \\(m\\) max aggregation order, \\(k^\\ast\\) sum (subset ) (\\(p-1\\)) factors \\(m\\), excluding \\(m\\), \\(h\\) forecast horizon lowest frequency time series, \\(L\\) sample size. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). fun string specifying reconciliation function used, implemented FoReco. ... Arguments passed fun","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tesample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal probabilistic reconciliation (sample approach) — tesample","text":"distributional::dist_sample object.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tesample.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Temporal probabilistic reconciliation (sample approach) — tesample","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003 Panagiotelis, ., Gamakumara, P., Athanasopoulos, G. Hyndman, R.J. (2023), Probabilistic forecast reconciliation: Properties, evaluation score optimisation, European Journal Operational Research 306(2), 693–706. doi:10.1016/j.ejor.2022.07.040","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tesample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal probabilistic reconciliation (sample approach) — tesample","text":"","code":"set.seed(123) m <- 4 # from quarterly to annual temporal aggregation  # (100 x 14) base forecasts sample matrix (simulated), m = 4, h = 2 sample <- t(sapply(1:100, function(x) rnorm(14, rep(c(20, 10, 5), 2*c(1, 2, 4))))) # (70 x 1) in-sample residuals vector (simulated) res <- rnorm(70)  # Optimal cross-sectional probabilistic reconciliation reco_dist_opt <- tesample(sample, agg_order = m, res = res, comb = \"shr\")  # Bottom-up probabilistic reconciliation reco_dist_bu <- tesample(sample[,-c(1:6)], agg_order = m, fun = tebu)  # Level conditional coherent probabilistic reconciliation reco_dist_lcc <- tesample(sample, agg_order = m, fun = telcc)"},{"path":"https://danigiro.github.io/FoReco/reference/tetd.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal top-down reconciliation — tetd","title":"Temporal top-down reconciliation — tetd","text":"Top-forecast reconciliation univariate time series, forecast aggregated temporal level disaggregated according proportional scheme (weights). Besides fulfilling aggregation constraint, top-reconciled forecasts respect two main properties: top-level value remains unchanged; bottom time series reconciled forecasts non-negative.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tetd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal top-down reconciliation — tetd","text":"","code":"tetd(base, agg_order, weights, tew = \"sum\", normalize = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/tetd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal top-down reconciliation — tetd","text":"base (\\(hm \\times 1\\)) numeric vector containing temporal aggregated base forecasts order \\(m\\); \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). weights (\\(hm \\times 1\\)) numeric vector containing proportions high-frequency time series; \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). normalize TRUE (default), weights sum 1.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tetd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal top-down reconciliation — tetd","text":"(\\(h(k^\\ast+m) \\times 1\\)) numeric vector temporal reconciled forecasts.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tetd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal top-down reconciliation — tetd","text":"","code":"set.seed(123) # (2 x 1) top base forecasts vector (simulated), forecast horizon = 2 topf <- rnorm(2, 10) # Same weights for different forecast horizons fix_weights <- runif(4) reco <- tetd(base = topf, agg_order = 4, weights = fix_weights)  # Different weights for different forecast horizons h_weights <- runif(4*2) recoh <- tetd(base = topf, agg_order = 4, weights = h_weights)"},{"path":"https://danigiro.github.io/FoReco/reference/tetools.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal reconciliation tools — tetools","title":"Temporal reconciliation tools — tetools","text":"useful tools forecast reconciliation temporal hierarchies.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tetools.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal reconciliation tools — tetools","text":"","code":"tetools(agg_order, fh = 1, tew = \"sum\", sparse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/tetools.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal reconciliation tools — tetools","text":"agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). fh Forecast horizon lowest frequency (temporally aggregated) time series (default 1). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). sparse Option return sparse matrices (default TRUE).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tetools.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal reconciliation tools — tetools","text":"list five elements: dim vector containing information maximum aggregation order (m), number factor (p), partial (ks) total sum (kt) factors. set vector temporal aggregation orders (decreasing order). agg_mat temporal linear combination aggregation matrix. strc_mat temporal structural matrix. cons_mat temporal zero constraints matrix.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tetools.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal reconciliation tools — tetools","text":"","code":"# Temporal framework (quarterly data) obj <- tetools(agg_order = 4, sparse = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/unbalance_hierarchy.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form — unbalance_hierarchy","title":"Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form — unbalance_hierarchy","text":"hierarchy \\(L\\) upper levels said balanced variable level \\(l\\) least one child level \\(l+1\\). hold, hierarchy unbalanced. function transforms aggregation matrix balanced hierarchy aggregation matrix unbalanced one, removing possible duplicated series.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/unbalance_hierarchy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form — unbalance_hierarchy","text":"","code":"unbalance_hierarchy(agg_mat, more_info = FALSE, sparse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/unbalance_hierarchy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form — unbalance_hierarchy","text":"agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. more_info TRUE, returns aggregation matrix unbalanced hierarchy. Default FALSE. sparse Option return sparse matrices (default TRUE).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/unbalance_hierarchy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form — unbalance_hierarchy","text":"list containing four elements (more_info = TRUE): ubm aggregation matrix unbalanced hierarchy. agg_mat input matrix. idrm identification number duplicated variables (row numbers aggregation matrix agg_mat). id identification number variable balanced hierarchy. may contains duplicated values.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/unbalance_hierarchy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form — unbalance_hierarchy","text":"","code":"#     Balanced     ->     Unbalanced #        T                    T #    |-------|            |-------| #    A       B            A       | #  |---|     |          |---|     | # AA   AB    BA        AA   AB    BA A <- matrix(c(1, 1, 1,               1, 1, 0,               0, 0, 1), 3, byrow = TRUE) obj <- unbalance_hierarchy(agg_mat = A) obj #> 2 x 3 sparse Matrix of class \"dgCMatrix\" #>            #> [1,] 1 1 1 #> [2,] 1 1 ."},{"path":"https://danigiro.github.io/FoReco/reference/vndata.html","id":null,"dir":"Reference","previous_headings":"","what":"Australian Tourism Demand dataset — vndata","title":"Australian Tourism Demand dataset — vndata","text":"Australian Tourism Demand dataset (Wickramasuriya et al. 2019) measures number nights Australians spent away home. includes 228 monthly observations Visitor Nights (VNs) January 1998 December 2016, cross-sectional grouped structure based geographic hierarchy crossed purpose travel. geographic hierarchy comprises 7 states, 27 zones, 76 regions, total 111 nested geographic divisions. Six zones formed single region, resulting 105 unique nodes hierarchy. purpose travel comprises four categories: holiday, visiting friends relatives, business, . avoid redundancies (Girolimetto et al. 2023), 24 nodes (6 zones formed single region) considered, resulting unbalanced hierarchy 525 (304 bottom 221 upper time series) unique nodes instead theoretical 555 duplicated nodes.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/vndata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Australian Tourism Demand dataset — vndata","text":"","code":"# 525 time series of the Australian Tourism Demand dataset vndata  # aggregation matrix vnaggmat"},{"path":"https://danigiro.github.io/FoReco/reference/vndata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Australian Tourism Demand dataset — vndata","text":"vndata \\((228 \\times 525)\\) ts object, corresponding 525 time series Australian Tourism Demand dataset (1998:01-2016:12). vnaggmat \\((221 \\times 304)\\) aggregation matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/vndata.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Australian Tourism Demand dataset — vndata","text":"https://robjhyndman.com/publications/mint/","code":""},{"path":"https://danigiro.github.io/FoReco/reference/vndata.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Australian Tourism Demand dataset — vndata","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting,  40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023.10.003 Wickramasuriya, S.L., Athanasopoulos, G. Hyndman, R.J. (2019), Optimal forecast reconciliation hierarchical grouped time series trace minimization, Journal American Statistical Association, 114, 526, 804-819. doi:10.1080/01621459.2018.1448825","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-development-version","dir":"Changelog","previous_headings":"","what":"FoReco (development version)","title":"FoReco (development version)","text":"Added csgauss(), tegauss(), ctgauss() Gaussian probabilistic forecast reconciliation cross-sectional, temporal, cross-temporal frameworks using distributional package; Added cssample(), tesample(), ctsample() sample-based probabilistic forecast reconciliation cross-sectional, temporal, cross-temporal frameworks using distributional package; Added as_ctmatrix() as_horizon_stacked_ctmatrix() functions convert horizon-stacked (cross-temporal version) cross-temporal layouts; Added as_tevector() as_horizon_stacked_tematrix() functions convert horizon-stacked (temporal version) temporal layouts; Fixed bugs improved stability.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-110","dir":"Changelog","previous_headings":"","what":"FoReco 1.1.0","title":"FoReco 1.1.0","text":"CRAN release: 2025-06-07","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"new-features-1-1-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"FoReco 1.1.0","text":"Wickramasuriya, S. L., Turlach, B. ., Hyndman, R. J. (2020), “Optimal non-negative forecast reconciliation”, Statistics Computing, 30(5), 1167–1182. doi:10.1007/s11222-020-09930-0; Ando, S., Xiao, M. (2023), “High-dimensional covariance matrix estimation: shrinkage toward diagonal target”, IMF Working Papers, 2023(257), A001; Redesigned bounds parameter enable bounded forecast reconciliation csrec(), terec(), ctrec() functions; Introduced new set_bounds() function define custom bounds reconciliation.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"bug-fixes-1-1-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"FoReco 1.1.0","text":"Fixed bug subset agg_order factors selected iterec(), tcsrec(), cstrec() functions.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-100","dir":"Changelog","previous_headings":"","what":"FoReco 1.0.0","title":"FoReco 1.0.0","text":"CRAN release: 2024-08-20 Note – latest release FoReco introduces significant changes function notation adds several new features. major update, FoReco 1.0, compatible previous versions due substantial changes made package’s core structure. previous version available Github (docs). Due significant changes FoReco 1.0, users advised carefully review updated documentation examples using new version. latest documentation release notes available danigiro.github.io/FoReco/ Updated Function Notation: functions related cross-sectional, temporal, cross-temporal frameworks now use prefixes cs, te, ct, respectively. example, optimal combination reconciliation functions now csrec(), terec(), ctrec(). Simplified Function Outputs: Reconciliation functions now return matrices. Additional information can accessed using attr(., \"FoReco\") recoinfo() function. New Datasets: Two new datasets, itagdp (Italian Quarterly National Accounts) vndata (Australian Tourism Demand), included along respective aggregation constraint matrices. Classic Approach: middle-approach (csmo(), temo(), ctmo()) implemented alongside classic bottom-(csbu(), tebu(), ctbu()) top-(cstd(), tetd(), cttd()) methods. Level Conditional Coherent Reconciliation: Level conditional coherent reconciliation now available constraints: cslcc() (cross-sectional), telcc() (temporal), ctlcc() (cross-temporal). Immutable reconciliation: immutable() parameter added reconciliation functions (csrec(), terec(), ctrec()) prevent base forecasts modified structural (approach='strc') zero-constrained (approach='proj') approach. Balanced unbalanced hierarchy: added balance_hierarchy() unbalance_hierarchy() dealing balanced unbalanced hierarchies. Projection Matrix Functions: Functions csprojmat(), teprojmat(), ctprojmat() added obtain projection matrices. Covariance Matrix Functions: Functions cscov(), tecov(), ctcov() added obtain covariance matrices. Function Renaming: Several functions renamed improve consistency clarity Cmatrix() -> df2aggmat() hts_tools() -> cstools() thf_tools() -> tetools() ctf_tools() -> cttools() agg_ts() -> aggts() residuals_matrix() -> res2matrix() boot_cs() -> csboot() boot_te() -> teboot() boot_ct() -> ctboot() htsrec() -> csrec() thfrec() -> terec() octrec() -> ctrec() lccrec() -> cslcc()","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-026","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.6","title":"FoReco 0.2.6","text":"CRAN release: 2023-05-16","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"major-changes-probabilistic-forecast-reconciliation-0-2-6","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.6","title":"FoReco 0.2.6","text":"Added boot_cs(), boot_te() boot_ct() draw samples , respectively, cross-sectional, temporal cross-temporal joint (block) bootstrap.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"minor-changes-0-2-6","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.6","title":"FoReco 0.2.6","text":"Fixed deprecation warnings Matrix (v. 1.5-0); Improved docs bug fixes; Fixed ctbu() inputs; Added FoReco2matrix() transform FoReco forecasts input output list matrix/vector class; Added agg_ts(): non-overlapping temporal aggregation time series according specific aggregation order; Added arrange_hres() residuals_matrix() functions arrange residuals covariance matrix Gaussianity.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-025","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.5","title":"FoReco 0.2.5","text":"CRAN release: 2022-07-04","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"minor-changes-0-2-5","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.5","title":"FoReco 0.2.5","text":"Fixed negative reconciliation “sntz” octrec(); Fixed documentation.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-024","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.4","title":"FoReco 0.2.4","text":"CRAN release: 2022-06-16","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"major-changes-0-2-4","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.4","title":"FoReco 0.2.4","text":"Added lcmat() function.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"minor-changes-0-2-4","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.4","title":"FoReco 0.2.4","text":"Fixed BU approach number columns basef equal number bottom time series htsrec(); Fixed score_index(); Fixed bounds param type = \"S\" htsrec(), thfrec() octrec(); Add possibility fix base forecasts v param htsrec(), thfrec() octrec() - experimental; Add two new type optimal cross-temporal reconciliation (cs_struc t_struc); Improved docs bug fixes.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-022","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.2","title":"FoReco 0.2.2","text":"CRAN release: 2022-02-17","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"minor-changes-0-2-2","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.2","title":"FoReco 0.2.2","text":"Fixed documentation; Removed ut2c() srref().","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-021","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.1","title":"FoReco 0.2.1","text":"CRAN release: 2021-07-23","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"minor-changes-0-2-1","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.1","title":"FoReco 0.2.1","text":"Fixed bug output lccrec() (now function returns Level Conditional Coherent Combined Conditional Coherent forecasts); Fixed negative reconciliation “KAnn” keep = \"list\".","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-020","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.0","title":"FoReco 0.2.0","text":"CRAN release: 2021-05-21","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"major-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.0","title":"FoReco 0.2.0","text":"’s possible use subset factors m (max. order temporal aggregation); Added possibility htsrec(), thfrec() octrec() introduce list h covariance matrices parameters W Omega, h stands forecast horizon (note thfrec() octrec() forecast horizon entire cycle); Param Sstruc avaible octrec() ctf_tools(). FoReco uses fast algorithm compute Scheck, external input needed; Modified output ctf_tools() (added Ccheck, Htcheck, Scheck, removed Cstruc, Sstruc), hts_tools() (added C) thf_tools() (added m); Added two new negative reconciliation techniques (“KAnn” “sntz”) new parameter (nn_type) htsrec(), thfrec() octrec(); Added top-reconciliation function tdrec(); Added level conditional forecast reconciliation (without -negative constraints) genuine hierarchical/grouped time series levrec() (cross-sectional, temporal cross-temporal).","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"minor-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.0","title":"FoReco 0.2.0","text":"Now octrec() also possible introduce Ω covariance matrix variant Omega parameter W variant W parameter; Updated tcsrec(), cstrec() iterec(). iterec() function maxit parameter replaced itmax, however moment maxit still supported; Now FoReco removes null rows cross-sectional aggregation matrix C warns user balanced version unbalanced hierarchy considering duplicated variables; Redesigned console output added new convergence norm default iterec() (norm parameter).","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"experimental-0-2-0","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.0","title":"FoReco 0.2.0","text":"Add possibility introduce constraints bounds param htsrec(), thfrec() octrec(); Add function oct_bounds() organize bounds specific dimension (.e. cross-sectional temporal) cross-temporal framework; Added ut2c() srref() develop cross-sectional structural representation starting zero constraints kernel matrix; Added score_index() calculation multiple forecast horizons index (like 1:6) multiple cross-sectional levels forecasting experiment.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-011","dir":"Changelog","previous_headings":"","what":"FoReco 0.1.1","title":"FoReco 0.1.1","text":"CRAN release: 2020-10-17 Minore release, fixing bugs documentation Fixed bug iterec() calculating incoherence Fixed documentation Changed contact mail (now ’s daniele.girolimetto@phd.unipd.) Corrected second section vignette “Average relative accuracy indices”","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-010","dir":"Changelog","previous_headings":"","what":"FoReco 0.1.0","title":"FoReco 0.1.0","text":"CRAN release: 2020-10-01 Release github","code":""}]
